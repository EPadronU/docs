@Include { "include/lib/licomteg.lout" }

@Doc @Text @Begin
@TEG
  @MyFirstName { Edinson }
  @MyLastName { Padrón Urdaneta }
  @MyIDNumber { 19.216.488 }
  @MyEmail { edinson.padron.urdaneta@gmail.com }
  @MyPhoneNumber { +58 414 6574149 }
  @MyAddress { Venezuela, Zulia, Maracaibo, Urb. La Paz, Calle 96D, Avenida 56 }
  @PaperTitle { Herramienta Web para la Clasificación y Recuperación de Información Digital Basada en Etiquetas }
  @IsReport { Y }
@Begin
  @Cover
    @Tutor { MSc. Gerardo Pirela Morillo }
    @Month { marzo }
    @Year { 2014 }

  @NP

  @Facade
    @TutorInfo {
      MSc. Gerardo Pirela Morillo @FF
      CI.: 12.404.565 @FF
      Teléfono: +58 412 1734718 @FF
      Correo electrónico: gepirela@fec.luz.edu.ve
    }

  @NP

  @ExtraSection
    @Title { }
    @AlterTitle { Dedicatoria }
    @BeforeIndex { true }
  @Begin
    //20v ||12f { rragged } @Break @I {
      A mis amorosos y pacientes padres, quienes me han acompañado y apoyado todo este tiempo; y a mi tutor, quien
      ha sido el mejor guía y amigo que un pupilo podría pedir.
    }
  @End @ExtraSection

  @NP

  @Summary
    @KeyWords { Aplicación web, Etiquetado, Clasificación, Recuperación, Información digital }
  @Begin
    @PP
    Los sistemas operativos modernos representan la información por ellos gestionados mediante el uso de una
    estructura jerárquica de directorios y archivos la cual pudiera resultar rígida por cuanto discrepa de la
    manera natural que el cerebro humano emplea para la clasificación y recuperación de información. En este
    trabajo de investigación se propuso el desarrollo de una herramienta web centralizada y multiplataforma con el
    objetivo de permitir a sus usuarios clasificar y recuperar su información digital mediante el uso de etiquetas.
    La implementación de este último modelo permite gestionar los archivos mediante su vínculo con palabras clave
    de alto contenido semántico y fácil construcción, estableciendo una estructura flexible en forma de red.
    @I OmniTag es la herramienta web que resultó del desarrollo de la presente investigación: una aplicación de
    fácil uso, flexible y robusta que pasó satisfactoriamente las pruebas de funcionalidad realizadas.
  @End @Summary

  @NP

  @Abstract
    @KeyWords { File System, Tags, Web application }
  @Begin
    @PP
    Modern operating systems represent the information they manage using a hierarchical structure of subfolders and
    files which may be considered rigid as it differs from the natural way in which the human brain classifies and
    recovers information. The author proposed the developmnet of a centralized, multiplatform web tool which would
    allow its users to classify and recover digital information via the use of tags. The implementation of such a
    model permits managing files through the use of links to keywords easy to construct and with high semantic
    value to its user, resulting in a flexible network of concepts associated to files. The application developed
    was named @I OmniTag and it is an easy-to-use, flexible, and robust web application which satisfactorily passed
    all functional tests it underwent.
  @End @Abstract

  @NP

  @IndexOfContents

  @NP

  @IndexOfTables

  @NP

  @IndexOfGraphics

  @NP

  @ExtraSection
    @Title { INTRODUCCIÓN }
    @AlterTitle { Introducción }
  @Begin
    @PP
    En la actualidad, los sistemas operativos representan la información digital por ellos gestionada mediante una
    estructura jerárquica en forma de árbol invertido y conformada por una serie de directorios y archivos que
    resulta rígida y de engorroso uso, además de ser un método de gestión de información que dista en gran medida
    de aquel empleado por el hombre a la hora de almacenar y recobrar algún fragmento de los conglomerados de
    datos, experiencias y sensaciones alojados en su cerebro.

    @PP
    Esta investigación se llevó a cabo con el objetivo de desarrollar una herramienta web para la clasificación y
    recuperación de información digital mediante el uso de etiquetas que permitiera representar de manera lógica
    los archivos contenidos en un medio de almacenamiento secundario mediante una estructura semejante en
    funcionalidad y apariencia al método natural empleado por el ser humano en la gestión de su memoria. Objetivo
    alcanzado y descrito en este documento a lo largo de cinco capítulos a saber:
    
    @PP
    En el capítulo I, la motivación de esta investigación se aborda con mayor profundidad y detalle, se describen
    sus objetivos y se delimita su alcance. En el capítulo II se exponen las principales características de las
    herramientas de gestión de información digital mediante el uso de etiquetas que fungieron como antecedentes de
    este documento, se condensa la descripción de los conceptos más fundamentales hallados en éste y se describen
    las herramientas que fueron empleadas en el desarrollo del sistema propuesto.

    @PP
    El capítulo III plantea la metodología aplicada en la elaboración y prueba de la herramienta, miestras que la
    estructura funcional de la misma es expuesta de manera cabal en el capítulo IV, en el cual se describen los
    módulos y algoritmos que conforman el sistema mediante diagramas y especificaciones detalladas. Finalmente, en
    el capítulo V se detallan los escenarios de prueba empleados para verificar la fiabilidad de la herramienta
    junto a los resultados obtenidos.
  @End @ExtraSection

  @NP

  @Chapter
    @Num { I }
    @Title { El Problema }
  @Begin
    @BeginSections
      @Section
        @Title { Planteamiento del Problema  y Justificación de la Investigación }
        @Tag { planteamiento }
      @Begin
        @AddToIndex
          @Title { Planteamiento del Problema  y Justificación de la Investigación }
          @Tag { planteamiento }

        @PP
        La época actual es llamada la ``era de la información'' (Giuliano, 1983) debido a la relevancia de ésta
        en la sociedad. Furth (1994) escribió: ``La información es actualmente tan vital, y tan intangible, como
        el aire que respiramos, el cual está lleno de ondas de radio''. Hoy en día es el bien más importante y
        valioso para toda compañía, país y grupo social, por lo que su refinamiento a partir de la abundante
        cantidad de datos que son creados cada segundo es un proceso primordial y que ofrece una ventaja
        significativa.
        @PP
        En el año 2010 se produjo y almacenó un estimado de dos exabytes de información (esto incluye todos los
        medios: libros, revistas, documentos, Internet, fotografías, televisión, radio, música, entre otros) de
        los cuales, el 93% era digital (Burgin, 2010). Dos años después, la cantidad de información digital
        generada, se elevó a 2.5 exabytes al día (IBM, 2012), evidenciando un crecimiento exponencial, con la
        Internet como principal catalizador de este fenómeno.
        @PP
        A la Internet se le suma el creciente uso de dispositivos móviles (teléfonos inteligentes, tabletas,
        lectores electrónicos, entre otros) que permiten la accesible y cómoda creación y consumo de información
        gracias a la web, lo cual provoca una cuantiosa producción de datos, además de contribuir con la
        heterogeneidad y descentralización de los mismos, ocasionando así que su tratamiento sea una tarea
        penosamente difícil de realizar.
        @PP
        En la actualidad, los distintos repositorios presentan al usuario la información digital en ellos
        almacenados mediante una estructura jerárquica de directorios en forma de árbol invertido. Esta
        representación, nacida en 1969 con el lanzamiento del sistema operativo Multics en respuesta a la
        necesidad de un sistema de almacenamiento secundario en un ambiente de multiprogramación (Multics,
        1968), rígida por causa de su inherente propiedad taxonómica, limita la manera en la que puede ser
        organizada la información, mediante una relación padre-hijo, y hace de la búsqueda de la misma un
        proceso arduo debido al uso de engorrosas rutas de directorios. Además, esta aproximación dista en gran
        medida del método natural usado por el hombre para almacenar y recuperar información de su memoria a
        largo plazo, el cual consiste en codificarla semánticamente para su almacenamiento (Baddeley, 1966),
        asociando los datos que percibe (Atkinson y Shiffrin, 1968). Por lo tanto, el ser humano no es una
        máquina que trabaje en base a datos aislados, éste busca interrelacionarlos, describiéndolos de manera
        inherentemente subjetiva, breve y dinámica; haciendo necesario un método semejante para clasificar y
        recuperar la información digital, siendo éste más flexible, intuitivo y natural.
        @PP
        Afortunadamente, la web ha dado origen a un nuevo sistema de clasificación. Originalmente diseñado e
        implantado por el servicio del.icio.us (Mathes, 2004), el sistema ofrece la posibilidad de describir
        recursos mediante un conjunto de palabras clave llamadas etiquetas (@I tags, por su término en inglés),
        las cuales son consideradas por los usuarios como relevantes para caracterizar dichos recursos de
        acuerdo a sus necesidades sin depender de un vocabulario controlado o de una estructura previamente
        definida, estableciendo así una relación entre el recurso y un concepto en su mente, con el objeto de
        organizar el contenido para uso futuro de una manera fácil y flexible (Specia y Motta, 2007). Este
        esquema de catalogación se ha extendido en uso por una gran variedad de servicios web debido a su
        popularidad entre los usuarios, quienes ven en éste una manera más natural, sencilla, rápida y personal
        de clasificar la información digital que les es de interés, hallándola posteriormente con mínimo
        esfuerzo, siendo ésta una mejor alternativa al problema de darle tratamiento a una gran cantidad de
        datos, contrastada con la estructura jerárquica que ofrecen los sistemas de archivos modernos.
        @PP
        Hoy en día, existe una serie de herramientas que extienden las capacidades de los sistemas de archivos
        al permitir el uso de etiquetas; sin embargo, estas herramientas presentan algunas limitaciones, tales
        como: el tratamiento exclusivo de una fracción de la información digital existente, su operación bajo un
        número reducido de plataformas, la prestación de un conjunto restringido de funcionalidades, entre
        otros.
        @PP
        Con este trabajo de investigación se buscó desarrollar una herramienta web integral que garantizara la
        interoperabilidad entre los distintos sistemas operativos y dispositivos al permitir un acceso
        convenientemente centralizado a la información digital sin importar la distribución física de ésta,
        brindando así transparencia de localización mediante el uso de un servidor central que contenga la
        herramienta y aplicaciones que enlacen los repositorios de los usuarios con dicho servidor. Además, se
        implantó una manera sencilla, versátil y personal de clasificar y recuperar la información digital
        contenida en los mencionados repositorios al permitir su descripción y recuperación mediante el uso de
        etiquetas definidas a conveniencia. Adaptando así la tecnología nacida en la web al ámbito de los
        actuales sistemas de archivo.
      @End @Section

      @Section
        @Title { Alcance del problema }
        @Tag { alcance }
      @Begin
        @AddToIndex @Title { Alcance del problema } @Tag { alcance }

        @PP
        La investigación estuvo delimitada al desarrollo de un sistema cliente-servidor donde el cliente,
        desarrollado para trabajar solo bajo los entornos Windows®, OS X® y Linux®, se comunica con una
        aplicación web, manteniendo sincronizadas las etiquetas asociadas a los archivos ubicados en los
        repositorios del usuario, permitiéndole así clasificarlos y recuperarlos mediante el uso de las
        mencionadas etiquetas.
      @End @Section

      @Section
        @Title { Objetivos }
        @Tag { objetivos }
      @Begin
        @AddToIndex @Title { Objetivos } @Tag { objetivos }

        @BeginSubSections
          @SubSection
            @Title { Objetivo General }
            @Tag { obj.gen }
          @Begin
            @AddToIndex @Title { Objetivo General } @Tag { obj.gen }

            //2.0f @BulletList
              @ListItem {
                Desarrollar una herramienta web para la clasificación y recuperación de información
                digital basada en etiquetas
              }
            @EndList
          @End @SubSection

          @SubSection
            @Title { Objetivos Específicos }
            @Tag { obj.esp }
          @Begin
            @AddToIndex @Title { Objetivos Específicos } @Tag { obj.esp }

            //2.0f @BulletList
            @ListItem {
              Realizar una revisión documental sobre herramientas de clasificación y recuperación de
              información digital
            }
            @ListItem {
              Implementar la aplicación servidor para el almacenamiento y gestión de etiquetas de recursos
              digitales
            }
            @ListItem {
              Desarrollar el módulo de la aplicación cliente encargada del rastreo personalizable de la
              información a etiquetar
            }
            @ListItem {
              Desarrollar el módulo de la aplicación cliente correspondiente a la interfaz web de usuario
            }
            @ListItem {
              Realizar las pruebas de caja gris de la herramienta
            }
            @EndList
          @End @SubSection
        @EndSubSections
      @End @Section
    @EndSections
  @End @Chapter

  @NP

  @Chapter
    @Num { II }
    @Title { Marco Teórico }
  @Begin
    @BeginSections
      @Section
        @Title { Antecedentes de la Investigación }
        @Tag { antecedentes }
      @Begin
        @AddToIndex @Title { Antecedentes de la Investigación } @Tag { antecedentes }

        @PP
        En la actualidad, los sistemas de clasificación basados en etiquetas son ampliamente usados por
        innumerables aplicaciones web, sin embargo, su uso como complemento a los sistemas de archivo modernos
        presenta una reducida gama de opciones, dentro de la cual se pueden mencionar:

        @BeginSubSections
          @SubSection
            @Title { Tags }
            @Tag { ant.tags }
          @Begin
            @AddToIndex @Title { Tags } @Tag { ant.tags }

            @PP
            Tags es una aplicación que permite etiquetar archivos y directorios en @I finder (explorador),
            correos electrónicos en @I Mail (gestor de emails), fotos en @I IPhoto (gestor de imágenes) y
            enlaces en @I Safari (navegador web); con el objetivo de mantener organizados dichos recursos y
            poder hallarlos de manera rápida y sencilla.
            @PP
            Tags también ofrece una vista previa de la información, atajos de teclado y una excelente
            integración con el sistema operativo. Desafortunadamente, esta aplicación solo está disponible
            para el sistema operativo @I { OS X }®, está sujeta a una licencia privativa y no es capaz de
            sincronizar recursos localizados en dispositivos diferentes.

            //2.0f @MyCenter @B { Imagen 1. Tags }
            //0f @PageMark { imagen1 }
            //0f @AddToGIndex @Title { Imagen 1. Tags } @Tag { imagen1 }
            //0f @CD { 0.4 0.28 } @Scale @IncludeGraphic "./include/img/tags.eps"
            //0f @MyCenter @B { Fuente: Tags (2014) }
          @End @SubSection

          @SubSection
            @Title { TagTool }
            @Tag { ant.tagtool }
          @Begin
            @AddToIndex @Title { TagTool } @Tag { ant.tagtool }

            @PP
            TaggTool permite añadir etiquetas a archivos, directorios y «bookmarks». Adicionalmente, el
            usuario puede proporcionar una descripción del recurso, además de una calificación cuantitativa
            (@I rating). Esta herramienta ofrece la posibilidad de importar metadatos pre-existentes en los
            recursos y realizar búsquedas en base a estos.
            @PP
            TaggTool también posee una alta integración con el sistema operativo y brinda una vista previa
            de los recursos gestionados. Además, facilita un sistema de etiquetado automático basado en la
            naturaleza de los recursos, y muestra una nube de etiquetas para la visualización de las
            mismas.
            @PP
            Al igual que Tags, TaggTool está sujeto a una licencia privativa y no es capaz de sincronizar
            recursos localizados en dispositivos diferentes. Otra desventaja que presenta este sistema
            es que está disponible solo para el sistema operativo @I { Microsoft Windows }®.

            //2.0f @MyCenter @B { Imagen 2. TaggTool }
            //0f @PageMark { imagen2 }
            //0f @AddToGIndex @Title { Imagen 2. TaggTool } @Tag { imagen2 }
            //0f @CD { 0.4 0.3 } @Scale @IncludeGraphic "./include/img/taggtool.eps"
            //0f @MyCenter @B { Fuente: TaggTool (2014) }
          @End @SubSection

          @SubSection
            @Title { Tables }
            @Tag { ant.tables }
          @Begin
            @AddToIndex @Title { Tables } @Tag { ant.tables }

            @PP
            Tabbles ofrece la posibilidad de clasificar, buscar, organizar y compartir (a través de una LAN
            o la Internet) archivos, carpetas y «bookmarks», mediante el uso de etiquetas. Adicionalmente,
            la herramienta ofrece un sistema de auto-etiquetado, además de una excelente integración con el
            sistema operativo.
            @PP
            A pesar de ser capaz de gestionar, compartir y sincronizar recursos localizados en dispositivos
            distintos, Tabbles está disponible únicamente para el sistema operativo Microsoft Windows® bajo
            una licencia privativa.

            //2.0f @MyCenter @B { Imagen 3. Tabbles }
            //0f @PageMark { imagen3 }
            //0f @AddToGIndex @Title { Imagen 3. Tabbles } @Tag { imagen3 }
            //0f @CD { 0.6  0.5 } @Scale @IncludeGraphic "./include/img/tabbles.eps"
            //0f @MyCenter @B { Fuente: Tabbles (2014) }
          @End @SubSection
        @EndSubSections
      @End @Section

      @Section
        @Title { Bases Teóricas }
        @Tag { bases.teoricas }
      @Begin
        @AddToIndex @Title { Bases Teóricas } @Tag { bases.teoricas }

        @BeginSubSections
          @SubSection
            @Title { Sistema de Archivo }
            @Tag { sis.arch }
          @Begin
            @AddToIndex @Title { Sistema de Archivo } @Tag { sis.arch }

            @PP
            Un sistema de archivo es un módulo central de todo sistema operativo moderno que consiste de
            estructuras lógicas y rutinas que controlan la creación, modificación, eliminación y acceso a los
            datos que residen en una unidad de disco, partición o volumen lógico. Dicho sistema organiza los
            datos en una estructura jerárquica mediante el uso de directorios, los cuales fungen como
            contenedores de punteros a múltiples archivos (EMC, 2012). Algunos de los sistemas de archivo más
            ampliamente usados en la actualidad son: FAT, FAT32, NTFS, HFS Plus, ext2, ext3 y ext4.
          @End @SubSection

          @SubSection
            @Title { Transparencia de Localización }
            @Tag { trans.loca }
          @Begin
            @AddToIndex @Title { Transparencia de Localización } @Tag { trans.loca }

            @PP
            Se refiere a una consideración de diseño de los sistemas operativos distribuidos. Se habla de
            transparencia de localización cuando un usuario accede a un recurso en particular sin que sea
            necesario conocer la ubicación del mismo dentro de la red de trabajo a fin de acceder a él. El no
            conocer la localización de un recurso implica que todo acceso a éste es realizado por medio de un
            nombre que no depende de la ubicación dónde reside actualmente, ni la ubicación dónde fue
            creado (Borghoff y Schlichter, 2000).
          @End @SubSection

          @SubSection
            @Title { Aplicación Web }
            @Tag { web.app }
          @Begin
            @AddToIndex @Title { Aplicación Web } @Tag { web.app }

            @PP
            Es una aplicación desarrollada mediante el uso de tecnologías web (html, css, javascript, entre otros)
            cuyo entorno de ejecución (@I{ runtime enviroment }) está conformado por un motor web (@I{ web engine }).
            Como ejemplos de este tipo de aplicaciones se pueden mencionar: sistemas de reservación, sitios de
            compras en línea, juegos, aplicaciones multimedia, mapas, aplicaciones interactivas de diseños,
            sistemas de correo, entre otros (W3C, 2012).

            @PP
            Los cuatros componentes típicos de una aplicación web son: un navegador, un servidor web, programas de
            aplicación y un servidor de base de datos. Las responsabilidades del navegador incluyen: presentar una
            interfaz de usuario, comunicarse con un servidor web, ejecutar @I{ scripts } embebidos, gestionar la
            @I{ cache } y las @I{ cookies }. El servidor web se encarga, entre otras cosas, de comunicarse con los
            clientes, proveer contenido estático, invocar programas de aplicación para la generación de contenido
            dinámico y gestionar las conexiones (Grove, 2009).

            @PP
            @I{ CGI }, @I{ servlets }, lenguajes de plantilla (@I{ template languages }) y lenguajes de guión
            (@I{ script languages }) son algunos de los entornos de desarrollo para la construcción de los
            programas de aplicación mencionados anteriormente, y están típicamente acompañados por un sistema de
            gestión de base de datos relacional (@I{ RDBMS }, por sus siglas en inglés) accedido por los programas
            de aplicación a través de un @I{ ODBC } "/" @I{ ORM } (Grove, 2009).
          @End @SubSection

          @SubSection
            @Title { ORM }
            @Tag { orm }
          @Begin
            @AddToIndex @Title { ORM } @Tag { orm }

            @PP
            Es una herramienta que permite conectar un objeto, a veces llamado ``modelo de dominio'', con una base de
            datos relacional de manera automática mediante el uso de metadatos como descriptores del objeto y los
            datos en sí mismos. Algunas de las ventajas que ofrece el uso de un ORM sobre otras técnicas de acceso
            de datos se listan a continuación: en primer lugar, se automatiza la conversión bidireccional entre
            objetos y tablas; además, se provee el almacenamiento en @I{ cache } de los objetos de manera
            transparente en el lado de la aplicación, mejorando así el rendimiento del sistema; y por último,
            brinda una API de acceso a la base de datos, abstrayendo por completo el sistema de gestión de bases de
            datos relacional (Mehta, 2008). @I{ ODB }, @I{ JDBC }, @I{ Peewee }, @I{ SQLAlchemist } y @I{ Yii } son
            algunos de los ORM usados en la actualidad.
          @End @SubSection

          @SubSection
            @Title { AJAX }
            @Tag { ajax }
          @Begin
            @AddToIndex @Title { AJAX } @Tag { ajax }

            @PP
            Es una tecnología empleada para prevenir la carga de una página en su totalidad al permitir la
            transferencia de datos entre el cliente y el servidor web de manera asíncrona, logrando que las páginas
            se carguen más rápidamente al retrasar la descarga de grandes recursos (Zakas, 2010).
          @End @SubSection

          @SubSection
            @Title { JSON }
            @Tag { json }
          @Begin
            @AddToIndex @Title { JSON } @Tag { json }

            @PP
            Es un formato ligero y fácil de analizar sintácticamente para representar datos, basado en el uso de la
            sintaxis dispuesta para los literales de tipo arreglo y objeto en el lenguaje de programación
            JavaScript, usado generalmente para transmitir información entre distintos sistemas de software (Zakas,
            2010). La serialización de información estructurada, tarea que se solía realizar con XML, es
            actualmente llevada a cabo mediante el uso del formato JSON, tendencia que crece con el pasar del
            tiempo.
          @End @SubSection

          @SubSection
            @Title { WSGI }
            @Tag { wsgi }
          @Begin
            @AddToIndex @Title { WSGI } @Tag { wsgi }

            @PP
            Es una interfaz simple y universal entre servidores y aplicaciones web para el lenguaje de programación
            Python (Eby, 2010). En términos simples, esta especificación establece la CGI (@I{ Common Gateway Interface })
            para el lenguaje de programación Python.
          @End @SubSection
        @EndSubSections
      @End @Section

      @Section
        @Title { Descripción de las Herramientas Usadas }
        @Tag  { herramientas.usadas }
        @Begin
          @AddToIndex @Title { Descripción de las Herramientas Usadas } @Tag  { herramientas.usadas }

        //2.0f @BulletList
          @ListItem {
            Python: es un lenguaje de programación interpretado y de propósito general que combina los paradigmas:
            orientado a objetos, imperativo y funcional. El dominio de aplicación del lenguaje va desde el
            desarrollo de herramientas y utilidades para la administración de sistemas y la construcción de páginas
            web ricas en características hasta la integración de componentes escritos en distintos lenguajes de
            programación, su uso en computación numérica y científica, el desarrollo de video juegos y la minería
            de datos (Lutz, 2010).
          }

          @ListItem {
            Flask: es un @I{ microframework } web para el lenguaje de programación Python. Su principal
            característica recae en poseer un conjunto de funcionalidades reducido y simple, brindando gran detalle
            a la extensibilidad de la herramienta, permitiéndole al usuario elegir los componentes a integrar,
            adaptándose así a las necesidades del proyecto a desarrollar y a las preferencias de los usuarios de
            manera flexible e indolora (Flask.org, 2014).
          }

          @ListItem {
            Pewee: es un ORM simple, escrito en python, que provee una interfaz ligera para realizar consultas SQL
            (Leifer, 2014).
          }

          @ListItem {
            SQLite: es una librería que implementa un motor de base de datos SQL transaccional y auto contenido.
            Sobresale entre sus características el poseer una arquitectura que no concibe la existencia de un
            proceso servidor, almacenando los datos gestionados en un archivo ordinario (SQLite.org, 2014).
          }

          @ListItem {
            Twitter bootstrap: es un @I{ framework } HTML, CSS y JavaScript para desarrollar proyectos web
            adaptables (@I{ responsive }) y orientados a dispositivos móviles (@I{ mobile first })
            (getbootstrap.com, 2014).
          }

          @ListItem {
            JQuery: es una librería escrita en JavaScript rápida, simple y con una gran repertorio de utilidades.
            Hace de la manipulación del DOM, el manejo de eventos, la creación de animaciones y el uso de Ajax,
            tareas mucho más sencillas de realizar a través de una API multiplataforma (JQuery.com, 2014).
          }
        @EndList
      @End @Section
    @EndSections
  @End @Chapter

  @NP

  @Chapter
    @Num { III }
    @Title { Marco Metodológico }
  @Begin
    @BeginSections
      @Section
        @Title { Descripción de la Metodología Empleada }
        @Tag { desc.met }
      @Begin
        @AddToIndex @Title { Descripción de la Metodología Empleada } @Tag { desc.met }

        @PP
        Para el desarrollo de la herramienta, fruto de esta investigación, se empleó la metodología @I{ Scrum }, la
        cual se define como un ``marco de trabajo en el cual las personas abordan problemas adaptativos complejos,
        entregando productos del más alto valor posible de manera productiva y creativa'' (Schwaber y Sutherland,
        2011).

        @PP
        @I{ Scrum } está fundamentada en el empirismo, el cual afirma que el conocimiento viene de la
        experiencia y que la toma de decisiones debe basarse en lo que se sabe. También, vale mencionar que esta
        metodología emplea un modelo iterativa e incremental para optimizar la capacidad de predicción y el control
        de riesgos.

        @PP
        El corazón del @I{ Scrum } es el @I{ Sprint }, el cual es un lapso de tiempo, cuya duración no supera la de
        un mes, durante el cual un incremento de un producto terminado, usable y potencialmente entregable es
        creado. Un @I{ Sprint } abarca lo que se va a construir, la elaboración de un plan flexible para llevar a
        cabo dicho proceso, la construcción en sí misma y el producto resultante.

        @PP
        En cuanto a las pruebas del sistema, se optó por la aplicación de dos tipos: pruebas funcionales orientadas
        a tareas (@I{ Task-Oriented Functional Tests }) y pruebas de errores forzados (@I{ Forced-Error Tests }),
        ambas ejecutadas bajo el modelo de caja gris.

        @PP
        De acuerdo a Hung Nguyen, Bob Johnson y Michael Hackett, las pruebas funcionales orientadas a tareas
        consisten de casos de prueba positivos que son diseñados para verificar las características del programa al
        asegurarse de que cada una de ellas se comporte como se espera, tomando en cuenta las especificaciones,
        guías de usuario, requerimientos y documentos de diseño. Cada característica es probada para:

        //2.0f @BulletList indent { 4s }
          @ListItem {
            Validar que la tarea se ejecute adecuadamente dadas condiciones de dato adecuadas bajo condiciones
            operativas favorables.
          }
          @ListItem {
            Verificar la integridad del resultado final de la tarea.
          }
          @ListItem {
            Asegurar la integridad de la característica cuando se usa junto a otras.
          }
        @EndList

        @PP
        Por su parte, las pruebas de errores forzados, según Nguyen, Johnson y Hackett, son casos de prueba
        negativos diseñados para forzar a un programa a pasar a condiciones de error. Debe generarse una lista de
        todos los mensajes de error que el programa emite. Esta lista es usada como base en el desarrollo de
        casos de prueba. Algunas recomendaciones a la hora de llevar a cabo este tipo de pruebas se describen a
        continuación:

        //2.0f @BulletList indent { 4s }
          @ListItem {
            Verificar que todas las condiciones de error comunes sean detectadas y manejadas correcta y
            consistentemente.
          }
          @ListItem {
            Verificar que el programa se recupere correctamente para toda condición de error.
          }
          @ListItem {
            Verificar que los estados inestables del programa, causados por un error, también sean corregidos.
          }
        @EndList

        @PP
        Por último, el modelo (o pruebas, como también es conocido) de caja gris incorpora elementos de las
        pruebas de caja negra y blanca. En las pruebas de caja gris se considera el resultado desde el punto de
        vista del usuario, el conocimiento técnico específico del sistema y el ambiente operativo; además, estas
        pruebas evalúan el diseño de la aplicación bajo el contexto de la interoperabilidad entre los componentes
        del sistema.

        @PP
        El modelo de caja gris es ideal para poner a prueba de manera efectiva aplicaciones web debido a que
        éstas abarcan numerosos componentes, tanto de software como de hardware. Estos componentes deben ser
        probados en el contexto del diseño del sistema para evaluar su funcionalidad y compatibilidad.
      @End @Section

      @Section
        @Title { Desarrollo de la Herramienta Balo la Metodología Scrum }
        @Tag { desarr.met }
      @Begin
        @AddToIndex @Title { Desarrollo de la Herramienta Balo la Metodología Scrum } @Tag { desarr.met }

        @PP
        El desarrollo de la herramienta web, Omnitag, se llevó a cabo a lo largo de nueve @I{ Sprints }, cada uno
        de un mes de duración. La distribución de las tareas llevadas a cabo a lo largo del ciclo de desarrollo se
        ha plasmado en la siguiente tabla, la descripción de las mismas se plantea justo después de la mencionada
        tabla.

        @NP

        //2.0f @MyCenter @B { Tabla 1. Distribución de Actividades }
        //0f @PageMark { dist.act }
        //0f @AddToTIndex @Title { Tabla 1. Distribución de Actividades } @Tag { dist.act }
        //0f @CD { 0.36 0.36 } @Scale @IncludeGraphic "./include/img/tabla1.eps"
        //0f @MyCenter @B { Fuente: Padrón (2014) }

        @BeginSubSections
          @SubSection
            @Title { Primer Sprint }
            @Tag { sp.1 }
          @Begin
            @AddToIndex @Title { Primer Sprint } @Tag { sp.1 }

            @PP
            Durante este @I{ sprint } se culminó la revisión de literatura relacionada con los sistemas de
            clasificación y recuperación de información digital basados en etiquetas, con la recopilación de los
            antecedentes de esta investigación. Además, se comenzó a diseñar e implementar la interfaz web de usuario
            a través del diseño de bocetos físicos y digitales; y la base de datos, mediante el esquema fundamental
            de la misma. Adicionalmente, se dio inicio al proceso de codificación e implementación de la aplicación
            servidor, diseñando la funcionalidad base para recibir y responder peticiones HTTP. Todo esto junto a las
            respectivas pruebas de caja gris de los componentes desarrollados, acción que se mantuvo durante todo el
            ciclo de desarrollo de la herramienta.
          @End @SubSection

          @SubSection
            @Title { Segundo Sprint }
            @Tag { sp.2 }
          @Begin
            @AddToIndex @Title { Segundo Sprint } @Tag { sp.2 }

            @PP
            Durante este @I{ sprint } se continuó con las actividades iniciadas en el anterior refinando el diseño
            de la base de datos, añadiendo nuevas características a la aplicación servidor y mejorando la interfaz
            web de usuario con el fin de hacerla más intuitiva y funcional.
          @End @SubSection

          @SubSection
            @Title { Tercer Sprint }
            @Tag { sp.3 }
          @Begin
            @AddToIndex @Title { Tercer Sprint } @Tag { sp.3 }

            @PP
            Al igual que en el anterior, durante este @I{ sprint } se dio continuidad a las labores anteriormente
            descritas, añadiendo un nuevo conjunto de características a la aplicación servidor, reflejando éstas
            mejoras en la interfaz web del usuario y dándole los toques finales a la base de datos, finalizando el
            proceso de diseño e implementación de la misma.
          @End @SubSection

          @SubSection
            @Title { Cuarto Sprint }
            @Tag { sp.4 }
          @Begin
            @AddToIndex @Title { Cuarto Sprint } @Tag { sp.4 }

            @PP
            En este @I{ Sprint } se comenzó el diseño de una API pública, implementada en la aplicación servidor,
            para permitir una comunicación sencilla con la misma, potenciando así la posibilidad de desarrollar una
            aplicación cliente que se comunique con la aplicación servidor de manera efectiva. También se hicieron
            un par de cambios menores a la interfaz web de usuario.
          @End @SubSection

          @SubSection
            @Title { Quinto Sprint }
            @Tag { sp.5 }
          @Begin
            @AddToIndex @Title { Quinto Sprint } @Tag { sp.5 }

            @PP
            Es en este @I{ Sprint } que se da inicio a la codificación e implementación de la aplicación cliente,
            conformada, al final de este ciclo, solo por el mecanismo de rastreo de recursos del sistema. Por otro
            lado, se sigue con la expansión de la API mencionada anteriormente y el refinamiento de la interfaz web
            de usuario, acciones que se repiten hasta el final del tercer lanzamiento.
          @End @SubSection

          @SubSection
            @Title { Sexto Sprint }
            @Tag { sp.6 }
          @Begin
            @AddToIndex @Title { Sexto Sprint } @Tag { sp.6 }

            @PP
            Se desarrolló el módulo que permite al usuario seleccionar a potestad cuáles directorios serán
            incluidos en el proceso de rastreo, así como el módulo que se encarga de mantener sincronizada con el
            servidor la información generada a partir del mencionado rastreo.
          @End @SubSection

          @SubSection
            @Title { Septimo Sprint }
            @Tag { sp.7 }
          @Begin
            @AddToIndex @Title { Septimo Sprint } @Tag { sp.7 }

            @PP
            A lo largo de este sprint, se implementó la gestión de usuarios en la aplicación servidor, se adaptó la
            interfaz web de usuario para reflejar dichos cambios y se implementó en ambas aplicaciones un mecanismo
            de comunicación sencillo, robusto y seguro, basado en @I{ tokens }.
          @End @SubSection

          @SubSection
            @Title { Octavo Sprint }
            @Tag { sp.8 }
          @Begin
            @AddToIndex @Title { Octavo Sprint } @Tag { sp.8 }

            @PP
            Durante este @I{ Sprint } se desarrolló e integró un mecanismo de etiquetado automático de la
            información rastreada.
          @End @SubSection

          @SubSection
            @Title { Noveno Sprint }
            @Tag { sp.9 }
          @Begin
            @AddToIndex @Title { Noveno Sprint } @Tag { sp.9 }

            @PP
            Este @I{ Sprint } cerró el ciclo de desarrollo de esta investigación, durante el cual se llevaron a
            cabo las pruebas más rigurosas del sistema, con la finalidad de detectar y posteriormente corregir
            errores funcionales que residían en la aplicación.
          @End @SubSection
        @EndSubSections
      @End @Section
    @EndSections
  @End @Chapter

  @NP

  @Chapter
    @Num { IV }
    @Title { OmniTag }
  @Begin
    @BeginSections
      @Section
        @Title { Arquitectura de la Herramienta }
        @Tag { arc.herr }
      @Begin
        @AddToIndex @Title { Arquitectura de la Herramienta } @Tag { arc.herr }

        @PP
        OmniTag es una herramienta que permite a sus usuarios organizar y buscar los archivos, contenidos en sus
        distintos computadores de escritorio y portátiles, a través del uso de etiquetas bajo una sola plataforma
        basada en tecnologías web y el lenguaje de programación Python. OmniTag relega a un navegador web el
        despliegue de su interfaz gráfica de usuario, construida mediante el uso de los lenguajes HTML y CSS junto
        al @I{ framework } Twitter Bootstrap, para la parte visual; y el lenguaje de programación JavaScript, con
        la ayuda de la librería JQuery, para la parte interactiva. La lógica de negocios es manejada por el
        interprete de Python, el cual se vale de una base de datos SQLite para gestionar la información no volátil,
        base de datos con la que interactúa mediante el ORM Peewee; y el @I{ framework } web Flask, encargado del
        manejo de las peticiones web, la transmisión de contenido estático, la ejecución de los programas de
        aplicación para generar contenido dinámico, entre otros.

        @PP
        Funcionalmente, OmniTag está constituida por dos módulos fundamentales: uno cliente y otro servidor. Ambos
        módulos dependen de un navegador web para interactuar con el usuario, haciendo uso de las tecnologías
        disponibles en dicho navegador para desplegar una interfaz interoperable con los distintos ambientes
        operativos, computadores de escritorio y portátiles de amplio uso en la actualidad.

        @PP
        El módulo servidor se ocupa de la gestión de todos los procesos relacionados con la creación, control y
        mantenimiento de los usuarios y sus correspondientes dispositivos. También se encarga de brindar las
        funcionalidades de visualización, etiquetado y búsqueda de los recursos almacenados en dichos dispositivos.
        La tarea de visualización se ofrece al usuario empleando una capa de transparencia de localización para un
        cómodo tratamiento de los recursos; el etiquetado es flexible, pudiendo aplicar o remover etiquetas a
        múltiples recursos a la vez, y la búsqueda es un proceso intuitivo permitiendo asociar un número arbitrario
        de palabras clave bajo un mismo término con el fin de potenciar, facilitar y agilizar la recuperación de
        los recursos.

        @PP
        Por su parte, el módulo cliente es la pieza destinada a residir en los dispositivos de los usuarios,
        permitiendo a éstos indicarle cuáles directorios de un repositorio en particular tomará en cuenta a la hora
        de rastrear los recursos que serán sincronizados con el módulo servidor para su posterior clasificación y
        recuperación. También es responsable de alojar los parámetros de configuración empleado para la
        comunicación con el servidor, además de ser el encargado de predefinir etiquetas a un subconjunto de los
        recursos rastreados, dependiendo su asignación de la naturaleza de los dichos recursos. La @B { Imagen 4}
        plasma la funcionalidad de estos módulos, así como la interacción que se da entre ellos y aquella que
        involucra al usuario.

        //2.0f @MyCenter @B { Imagen 4. Arquitectura Funcional de la Herramienta }
        //0f @PageMark { imagen4 }
        //0f @AddToGIndex @Title { Imagen 4. Arquitectura Funcional de la Herramienta } @Tag { imagen4 }
        //0f @CD { 0.6 } @Scale @IncludeGraphic "./include/img/arquitectura-funcional.eps"
        //0f @MyCenter @B { Fuente: Padrón (2014) }
      @End @Section

      @Section
        @Title { Implementación de la Herramienta }
        @Tag { impl.herr }
      @Begin
        @AddToIndex @Title { Implementación de la Herramienta } @Tag { impl.herr }

        @PP
        La @B { Imagen 5 } ilustra los modelos que forman parte del módulo servidor, cabe mencionar que ésta
        describe los atributos de los modelos y las relaciones que existen entre ellos tomando en cuenta su
        representación en forma de tablas bajo un paradigma relacional, estando éstas intrínsecamente vinculadas
        con sus correspondientes clases (paradigma orientado a objetos) mediante el uso del @I{ Peewee } (ORM).
        Estos modelos son:

        //2.0f @BulletList indent { 4s }
          @ListItem { User: Representa un usuario de la herramienta. }
          @ListItem { Device: Representa un dispositivo de un usuario. }
          @ListItem { Tag: Representa una etiqueta, la cual pertenece a un usuario único. }
          @ListItem { Resource: Representa un recurso alojado en dispositivo en particular. }
          @ListItem { Search: Representa asociaciones de etiquetas usadas en búsquedas almacenadas. }
        @EndList

        //2.0f @MyCenter @B { Imagen 5. Diagrama de Clases de los Modelos }
        //0f @PageMark { imagen5 }
        //0f @AddToGIndex @Title { Imagen 5. Diagrama de Clases de los Modelos } @Tag { imagen5 }
        //0f @CD 0.4 @Scale @IncludeGraphic "./include/img/classes-serv.eps"
        //0f @MyCenter @B { Fuente: Padrón (2014) }

        @PP
        Como puede observarse, adicional a los atributos de los modelos, éstos comparten una interfaz común,
        definida por la clase @I{ BaseModel }, además de tener asociados un conjunto de métodos, a saber:

        //2.0f @BulletList indent { 4s }
          @ListItem {
            @I{ BaseModel }: Pauta la interfaz mínima que debe poseer todo modelo, definiendo tres métodos:
            @I{ exists }, para verificar la existencia de un registro en particular en la base de datos
            correspondiente; @I{ get_by_id }, que retorna un conjunto de registros dada una lista de
            identificadores; y por último, @I{ json }, el cual se encarga de convertir en formato @I{ JSON } un
            registro en particular.
          }
          @ListItem {
            @I{ Tag }: Solo define un método: @I{ get_by_name }, que se encarga de devolver todos aquellos
            registros que correspondan a una lista de nombres en particular.
          }
          @ListItem {
            @I{ Search }: Similar a @I{ Tag }, esta clase define solo un método @I{ get_by_name }, el cual, a
            partir de una lista de nombres, retorna todos los recursos cuyo nombre se encuentra en la mencionada
            lista.
          }
          @ListItem {
            @I{ Resource }: Esta clase define un método llamado @I{ get_untagged_resources } que se encarga de
            devolver todos aquellos recursos que no poseen asociación alguna con una etiqueta.
          }
          @ListItem {
            @I{ TagSearch }: Establece la relación que existe entre las etiquetas y las búsquedas. Esta clase
            ofrece un método @I{ get_tags_by_search } que retorna todas las etiquetas asociadas a una búsqueda en
            particular.
          }
          @ListItem {
            @I{ TagResource }: Funge como vínculo entre las etiquetas y los recursos. El método @I{
            get_resources_by_tag } permite obtener todos los recursos que se encuentran asociados a un conjunto
            arbitrario de etiquetas.
          }
        @EndList

        @PP
        En el caso del módulo cliente, se presenta a continuación un diagrama de clases que muestra la estructura
        interna del mismo.

        //2.0f @MyCenter @B { Imagen 6. Diagrama de Clases del Módulo Cliente }
        //0f @PageMark { imagen6 }
        //0f @AddToGIndex @Title { Imagen 6. Diagrama de Clases del Módulo Cliente } @Tag { imagen6 }
        //0f @CD 0.4 @Scale @IncludeGraphic "./include/img/classes-clnt.eps"
        //0f @MyCenter @B { Fuente: Padrón (2014) }

        //2.0f @BulletList indent { 4s }
          @ListItem {
            @I{ Manager }: se encargar de la generación, lectura y respaldo de los archivos de configuración y
            estado del sistema, así como también de la comunicación con el módulo servidor. Los métodos asociados a
            esta clase son: @I{ __backup_thread } y @I{ __sync_thread } contienen los hilos que se encargan del
            respaldo de las variables de estado y la sincronización de los archivos rastreados con el servidor,
            respectivamente; @I{ start_backup_daemon } y @I{ start_sync_daemon } se encargan de ejecutar los hilos
            mencionados anteriormente; @I{ __add_to_black_list } y @I{ __add_to_white_list } controlan la inserción
            de directorios en la lista negra y blanca, de manera
            correspondiente.
          }
          @ListItem {
            @I{ DaemonThread }: es la clase usada para generar los hilos de ejecución asíncrona y que extiende a la
            clase @I{ Thread } del módulo @I{ threading } de la librería estándar del lenguaje de programación
            Python.
          }
          @ListItem {
            @I{ Cache }: es la clase sobre la cual @I{ Manager } confía las tareas de respaldo de las variables de
            estado. Los métodos definidos en esta clase son: @I{ __check_all }, @I{ __check_integrity } y
            @I{ __check_state }, empleados para verificar la integridad del estado interno de toda instancia de la
            clase; @I{ __get_default_base_dir } retorna el directorio base a usar por defecto; @I{ __load } carga
            en memoria las variables de estado serializadas en el medio de almacenamiento secundario del
            dispositivo en formato JSON; @I{ dump }, lleva a cabo el proceso inverso que realiza @I{ __load }; y,
            por último, los métodos @I{ get } y @I{ set } controlan el acceso y redefinición de las variables
            respaldadas.
          }
          @ListItem {
            @I{ SyncAgent }: es usada por la clase @I{ Manager } para mantener los archivos rastreados en
            sincronización con el servidor. Los métodos de esta clase son: @I{ __build_request } construye una
            petición HTTP a partir de una lista de archivos, petición usada por la conexión generada por
            @I{ __build_connection }; el método @I{ sync } lleva a cabo la sincronización mediante el uso de la
            conexión mencionada anteriormente.
          }
          @ListItem {
            @I{ Crawler }: encapsula las rutinas relacionadas con el rastreo de recursos en el dispositivo del
            usuario. Los métodos definidos es esta clase son los siguientes: @I{ __check_state } verifica la
            integridad del estado interno de toda instancia de la clase; @I{ __crawl_directory } determina, dada
            la ruta de un directorio, si éste debe o no ser tomado en cuenta en el rastreo de archivos; y, por
            último, @I{ crawl } ejecuta el rastreo.
          }
          @ListItem {
            @I{ AutoTagger }: esta clase se encarga de relacionar etiquetas a los archivos rastreados de manera
            automática en función de la extensión de éstos. El único método de esta clase se llama @I{ process },
            el cuál ejecuta el etiquetado automático de los archivos indicados.
          }
          @ListItem {
            @I{ SettingsForm }: es empleada para la recepción y validación de los parámetros de configuración
            proporcionados por los usuarios a través de la interfaz gráfica. Los métodos definidos en esta clase se
            describen a continuación: @I{ validate } verifica la integridad de la información enviada por el
            usuario y @I{ update_setings } se encarga de comunicar al resto de la aplicación los nuevos valores de
            los parámetros de configuración.
          }
        @EndList

        @PP
        A continuación, se presenta el código fuente de los procesos de rastreo y auto-etiquetado de archivos,
        componentes más sobresalientes del sistema:

        //2.0f @MyCenter @B { Imagen 7. Crawler }
        //0f @PageMark { imagen7 }
        //0f @AddToGIndex @Title { Imagen 7. Crawler } @Tag { imagen7 }
        //0f @CD 0.36 @Scale @IncludeGraphic "./include/img/crawler.eps"
        //0f @MyCenter @B { Fuente: Padrón (2014) }

        //2.0f @MyCenter @B { Imagen 8. AutoTagger }
        //0f @PageMark { imagen8 }
        //0f @AddToGIndex @Title { Imagen 8. AutoTagger } @Tag { imagen8 }
        //0f @CD 0.36 @Scale @IncludeGraphic "./include/img/auto-tagger.eps"
        //0f @MyCenter @B { Fuente: Padrón (2014) }
      @End @Section
    @EndSections
  @End @Chapter

  @NP

  @ExtraSection
    @Title { CONCLUSIONES }
    @AlterTitle { Conclusiones }
  @Begin
    @PP
    @I Omnitag, la herramienta producto de este trabajo de investigación, fue desarrollada con el objetivo de
    permitir la clasificación y recuperación de información digital mediante el uso de etiquetas. Este modelo de
    gestión de información se logró gracias a la implementación de una arquitectura cliente-servidor y al
    desarrollo apoyado en tecnologías web, factores que contribuyeron al aspecto centralizado y multiplataforma de
    la herramienta.

    @PP
    El proceso que concluyó con el nacimiento de @I Omnitag partió de la implementación de la aplicación servidor,
    cuya principal tarea es el almacenamiento y gestión de etiquetas y metadatos de recursos digitales. Los
    procesos de almacenamiento y gestión fueron garantizados mediante el empleo de una base de datos relacional y
    un servicio web, respectivamente.

    @PP
    El primero de los dos módulos que constituyen la aplicación cliente fue dispuesto para efectuar el rastreo
    personalizable de la información a etiquetar, manteniendo sincronizada dicha información con el servidor. El
    segundo módulo fue destinado a la interfaz gráfica del usuario, construida con la ayuda de tecnologías web
    (HTML, CSS, JavaScript) para facilitar su despliegue en distintos sistemas operativos.

    @PP
    Finalmente, se sometió a @I OminiTag a una serie de pruebas mediante el modelo de caja gris, pruebas pasadas
    con éxito por la herramienta y documentadas en detalle con el apoyo de una secuencia de capturas de pantalla
    para una mejor apreciación del comportamiento de la herramienta frente a las situaciones diseñadas en las
    pruebas.
  @End @ExtraSection

  @NP

  @ExtraSection
    @Title { RECOMENDACIONES }
    @AlterTitle { Recomendaciones }
  @Begin
    @PP
    Se recomienda implementar la herramienta en dispositivos móviles, así como también integrarla a los principales
    navegadores web para ofrecer a los usuarios la posibilidad de gestionar los archivos almacenados en teléfonos
    inteligentes y tabletas, y sincronizar sus @I bookmarks respectivamente.

    @PP
    Se sugiere el desarrollo de un módulo para el recabado y visualización de información estadística,
    constituyendo información como cantidad y uso de etiquetas y dispositivos de manera gráfica (nube de etiquetas)
    o numérica; y un grafo que muestre la relación y topología derivada de las palabras clave y su uso en los
    recursos gestionados.

    @PP
    Se aconseja integrar la herramienta con un servicio web de alojamiento de archivos (Dropbox, Google Drive,
    Microsoft OneDrive, entre otros) con el fin de respaldar la información gestionada por @I OmniTag o efectuar la
    transferencia de dicha información entre los dispositivos conectados a través de este tipo de servicio.
  @End @ExtraSection

  @NP

  @ExtraSection
    @Title { REFERENCIAS BIBLIOGRÁFICAS }
    @AlterTitle { Referencias bibliográficas }
  @Begin
    //0.9v
    Atkinson, R.C.; Shiffrin, R.M. (1968). Chapter: Human memory: A proposed system and its control
    processes. The psychology of learning and motivation. pp. 89-195.

    //0.9v
    Baddeley, A.D. (1966). The influence of acoustic and semantic similarity on long-term memory for word
    sequences. The Quarterly Journal of Experimental Psychology. pp. 302-309.

    //0.9v
    Borghoff, Uwe; Schlichter, Johann (2000). Computer-Supported Cooperative Work: Introduction to
    Distributed Applications. Springer Science y Business Media. p. 6.

    //0.9v
    Burgin, Mark (2010). Theory of Information: Fundamentality, Diversity and Unification. World Scientific.
    p. VI.

    //0.9v
    Eby, Phillip (2010) (Página consultada el 16 de julio de 2014) [On-line]. Dirección:
    "http://legacy.python.org/dev/peps/pep-3333".

    //0.9v
    EMC Education Services (2012). Information Storage and Management: Storing, Managing, and Protecting
    Digital Information in Classic, Virtualized, and Cloud Environments. John Wiley "&" sons. p. 6.

    //0.9v
    Flask.org (2014)(Página consultada el 19 de julio de 2014) [On-line]. Dirección: "http://flask.pocoo.org/".

    //0.9v
    Furth, J. (1994). The Information Age in Charts, Fortune International.

    //0.9v
    getbootstrap.com (2014) (Página consultada el 19 de julio de 2014) [On-line]. Dirección:
    "http://getbootstrap.com/".

    //0.9v
    Giuliano, V.E. (1983). The United States of America in the Information Age, en Information Policy and
    Scientific Research, Elsevier, Amsterdam, pp. 59-76.

    //0.9v
    Grove, Ralph (2009). Web Based Application Development. Jones "&" Bartlett Publishers. p. 42.

    //0.9v
    IBM (2012) (Página consultada el 25 de junio de 2013) [On-line]. Dirección:
    "www-01.ibm.com/software/data/bigdata/"

    //0.9v
    JQuery.com (2014) (Página consultada el 19 de julio de 2014) [On-line]. Dirección: "http://jquery.com/".

    //0.9v
    Leifer, Charles (2014) (Página consultada el 19 de julio de 2014) [On-line]. Dirección:
    "http://peewee.readthedocs.org/".

    //0.9v
    Lutz, Mark (2010). Programming Python. O"'"Reilly Media, Inc.

    //0.9v
    Mathes, Adam (2004) (Página consultada el 25 de junio de 2013) [On-line]. Dirección:
    "www.adammathes.com/academic/computer-mediated-communication/folksonomies.html"

    //0.9v
    Mehta, Vijay (2008). Pro LINQ Object Relational Mapping in C"#" 2008. Apress. pp. 4-5.

    //0.9v
    Multics (1968) (Página consultada el 25 de junio de 2013) [On-line]. Dirección:
    "www.multicians.org/fjcc4.html"

    //0.9v
    Nguyen, Hung; Johnson, Bob; Hackett, Michael (2003). Testing Applications on the Web: Test Planning for
    Mobile and Internet-Based Systems. Second Edition. Wiley Publishing, Inc.

    //0.9v
    Schwaber, Ken; Sutherland, Jeff (2011). The Definitive Guide to Scrum: The Rules of the Game.

    //0.9v
    Specia, Lucia; Motta, Enrico (2007). Integrating Folksonomies with the Semantic Web. Knowledge Media
    Institute - The Open University.

    //0.9v
    SQLite.org (2014) (Página consultada el 19 de julio de 2014) [On-line]. Dirección:
    "https://sqlite.org/about.html".

    //0.9v
    World Wide Web Consortium (2012) (Página consultada el 16 de julio de 2014) [On-line]. Dirección:
    "http://www.w3.org/2012/webapps/charter/"

    //0.9v
    Zakas, Nicholas (2010). High Performance JavaScript. O"'"Reilly Media, Inc.
  @End @ExtraSection
@End @TEG
@End @Text
