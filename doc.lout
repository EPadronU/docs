@Include { "include/lib/licomteg.lout" }

@Doc @Text @Begin
@TEG
  @MyFirstName { Edinson }
  @MyLastName { Padrón Urdaneta }
  @MyIDNumber { 19.216.488 }
  @MyEmail { edinson.padron.urdaneta@gmail.com }
  @MyPhoneNumber { +58 414 6574149 }
  @MyAddress { Venezuela, Zulia, Maracaibo, Urb. La Paz, Calle 96D, Avenida 56 }
  @PaperTitle { Herramienta Web para la Clasificación y Recuperación de Información Digital Basada en Etiquetas }
  @IsReport { Y }
@Begin
  @Cover
    @Tutor { MSc. Gerardo Pirela Morillo }
    @Month { octubre }
    @Year { 2014 }

  @NP

  @Facade
    @TutorInfo {
      MSc. Gerardo Pirela Morillo @FF
      CI.: 12.404.565 @FF
      Teléfono: +58 412 1734718 @FF
      Correo electrónico: gepirela@fec.luz.edu.ve
    }

  @NP

  @ExtraSection
    @Title { }
    @AlterTitle { Dedicatoria }
    @BeforeIndex { true }
  @Begin
    //20v ||12f { rragged } @Break @I {
      A mis amorosos y pacientes padres, quienes me han acompañado y apoyado todo este tiempo; y a mi tutor, quien
      ha sido el mejor guía y amigo que un pupilo podría pedir.
    }
  @End @ExtraSection

  @NP

  @Summary
    @KeyWords { Aplicación web, Etiquetado, Clasificación, Recuperación, Información digital }
  @Begin
    @PP
    Los sistemas operativos modernos representan la información por ellos gestionada mediante el uso de una
    estructura jerárquica de directorios y archivos la cual pudiera resultar rígida por cuanto discrepa de la
    manera natural que el cerebro humano emplea para la clasificación y recuperación de información. En este
    trabajo de investigación se propuso el desarrollo de una herramienta web centralizada y multiplataforma con el
    objetivo de permitir a sus usuarios clasificar y recuperar su información digital mediante el uso de etiquetas.
    La implementación de este último modelo permite gestionar los archivos mediante su vínculo con palabras clave
    de alto contenido semántico y fácil construcción, estableciendo una estructura flexible en forma de red.
    @I OmniTag es la herramienta web que resultó del desarrollo de la presente investigación: una aplicación de
    fácil uso, flexible y robusta que pasó satisfactoriamente las pruebas de funcionalidad realizadas.
  @End @Summary

  @NP

  @Abstract
    @KeyWords { File System, Tags, Web application }
  @Begin
    @PP
    Modern operating systems represent the information they manage using a hierarchical structure of subfolders and
    files which may be considered rigid as it differs from the natural way in which the human brain classifies and
    recovers information. The author proposed the developmnet of a centralized, multiplatform web tool which would
    allow its users to classify and recover digital information via the use of tags. The implementation of such a
    model permits managing files through the use of links to keywords easy to construct and with high semantic
    value to its user, resulting in a flexible network of concepts associated to files. The application developed
    was named @I OmniTag and it is an easy-to-use, flexible, and robust web application which satisfactorily passed
    all functional tests it underwent.
  @End @Abstract

  @NP

  @IndexOfContents

  @NP

  @IndexOfTables

  @NP

  @IndexOfGraphics

  @NP

  @ExtraSection
    @Title { INTRODUCCIÓN }
    @AlterTitle { Introducción }
  @Begin
    @PP
    En la actualidad, los sistemas operativos representan la información digital por ellos gestionada mediante una
    estructura jerárquica en forma de árbol invertido, conformada por una serie de directorios y archivos. Este
    método de gestión de información dista en gran medida de aquel empleado por el hombre a la hora de almacenar y
    recordar algún fragmento de los conglomerados de datos, experiencias y sensaciones alojados en su cerebro.

    @PP
    Esta investigación se llevó a cabo con el objetivo de desarrollar una herramienta web para la clasificación y
    recuperación de información digital que permitiera representar de manera lógica los archivos contenidos en un
    medio de almacenamiento secundario mediante estructuras semejantes en funcionalidad y apariencia al método
    natural empleado por el ser humano en la gestión de su memoria, a través del uso de etiquetas.
    
    @PP
    El presente documento está estructurado por cinco capítulos a saber: en el capítulo I se aborda la motivación
    de esta investigación, se describen sus objetivos y se delimita su alcance. En el capítulo II se exponen las
    principales características de las herramientas de gestión de información digital mediante el uso de etiquetas
    que fungieron como antecedentes para esta investigación, se condensa la descripción de los conceptos
    fundamentales hallados en este documento y se describen las herramientas que fueron empleadas en el desarrollo
    del sistema propuesto.

    @PP
    El capítulo III plantea la metodología aplicada en la elaboración y pruebas de la herramienta, mientras que la
    estructura funcional de la misma es expuesta de manera cabal en el capítulo IV, en el cual se describen los
    módulos y algoritmos que conforman el sistema mediante diagramas y especificaciones. Finalmente, en el capítulo
    V se detallan los escenarios de prueba empleados para verificar la fiabilidad de la herramienta junto a los
    resultados obtenidos.
  @End @ExtraSection

  @NP

  @Chapter
    @Num { I }
    @Title { El Problema }
  @Begin
    @BeginSections
      @Section
        @Title { Planteamiento del Problema  y Justificación de la Investigación }
        @Tag { planteamiento }
      @Begin
        @AddToIndex
          @Title { Planteamiento del Problema  y Justificación de la Investigación }
          @Tag { planteamiento }

        @PP
        La época actual es llamada la ``era de la información'' (Giuliano, 1983) debido a la relevancia de ésta
        en la sociedad. Furth (1994) escribió: ``La información es actualmente tan vital, y tan intangible, como
        el aire que respiramos, el cual está lleno de ondas de radio''. Hoy en día es el bien más importante y
        valioso para todo grupo social, organización y país, por lo que su refinamiento a partir de la abundante
        cantidad de datos que son creados cada segundo es un proceso primordial, el cual ofrece una ventaja
        significativa.
        @PP
        En el año 2010 se produjo y almacenó un estimado de dos exabytes de información (esto incluye todos los
        medios: libros, revistas, documentos, Internet, fotografías, televisión, radio, música, entre otros) de
        los cuales, el 93% era digital (Burgin, 2010). Dos años después, la cantidad de información digital
        generada se elevó a 2.5 exabytes al día (IBM, 2012), evidenciando un crecimiento exponencial, con la
        Internet como principal catalizador de este fenómeno.
        @PP
        A la Internet se le suma el creciente uso de dispositivos móviles (teléfonos inteligentes, tabletas,
        lectores electrónicos, entre otros) que permiten la accesible y cómoda creación y consumo de información
        gracias a la web, lo cual provoca una cuantiosa producción de datos, además de contribuir con la
        heterogeneidad y descentralización de los mismos, ocasionando así que su tratamiento sea una tarea
        penosamente difícil de realizar.
        @PP
        En la actualidad, los distintos repositorios presentan al usuario la información digital en ellos
        almacenados mediante una estructura jerárquica de directorios en forma de árbol invertido. Esta
        representación, nacida en 1969 con el lanzamiento del sistema operativo Multics en respuesta a la
        necesidad de un sistema de almacenamiento secundario en un ambiente de multiprogramación (Multics,
        1968), rígida por causa de su inherente propiedad taxonómica, limita la manera en la que puede ser
        organizada la información, mediante una relación padre-hijo, y hace que la búsqueda de la misma sea un
        proceso arduo debido al uso de engorrosas rutas de directorios. Además, esta aproximación dista en gran
        medida del método natural usado por el hombre para almacenar y recuperar información de su memoria a
        largo plazo, el cual consiste en codificarla semánticamente para su almacenamiento (Baddeley, 1966),
        asociando los datos que percibe (Atkinson y Shiffrin, 1968). Por lo tanto, el ser humano no es una
        máquina que trabaje en base a datos aislados; éste busca interrelacionarlos, describiéndolos de manera
        inherentemente subjetiva, breve y dinámica; haciendo necesario un método semejante para clasificar y
        recuperar la información digital, siendo éste más flexible, intuitivo y natural.
        @PP
        Afortunadamente, la web ha dado origen a un nuevo sistema de clasificación. Originalmente diseñado e
        implantado por el servicio del.icio.us (Mathes, 2004), el sistema ofrece la posibilidad de describir
        recursos mediante un conjunto de palabras clave llamadas etiquetas (@I tags, por su término en inglés),
        las cuales son consideradas por los usuarios como relevantes para caracterizar dichos recursos de
        acuerdo a sus necesidades sin depender de un vocabulario controlado o de una estructura previamente
        definida, estableciendo así una relación entre el recurso y un concepto en su mente, con el objeto de
        organizar el contenido para uso futuro de una manera fácil y flexible (Specia y Motta, 2007). Este
        esquema de catalogación se ha extendido en uso por una gran variedad de servicios web debido a su
        popularidad entre los usuarios, quienes ven en éste una manera más natural, sencilla, rápida y personal
        de clasificar la información digital que les es de interés, hallándola posteriormente con mínimo
        esfuerzo, siendo ésta una mejor alternativa al problema de darle tratamiento a una gran cantidad de
        datos, contrastada con la estructura jerárquica que ofrecen los sistemas de archivos modernos.
        @PP
        Hoy en día, existe una serie de herramientas que extienden las capacidades de los sistemas de archivos
        al permitir el uso de etiquetas; sin embargo, estas herramientas presentan algunas limitaciones, tales
        como: el tratamiento exclusivo de una fracción de la información digital existente, su operación bajo un
        número reducido de plataformas, la prestación de un conjunto restringido de funcionalidades, entre
        otros.
        @PP
        Con este trabajo de investigación se buscó desarrollar una herramienta web integral que garantizara la
        interoperabilidad entre los distintos sistemas operativos y dispositivos al permitir un acceso
        convenientemente centralizado a la información digital sin importar la distribución física de ésta,
        brindando así transparencia de localización mediante el uso de un servidor central que contenga la
        herramienta y aplicaciones que enlacen los repositorios de los usuarios con dicho servidor. Además, se
        implantó una manera sencilla, versátil y personal de clasificar y recuperar la información digital
        contenida en los mencionados repositorios al permitir su descripción y recuperación mediante el uso de
        etiquetas definidas a conveniencia. Adaptando así la tecnología nacida en la web al ámbito de los
        actuales sistemas de archivo.
      @End @Section

      @Section
        @Title { Alcance del problema }
        @Tag { alcance }
      @Begin
        @AddToIndex @Title { Alcance del problema } @Tag { alcance }

        @PP
        La investigación estuvo delimitada al desarrollo de un sistema cliente-servidor donde el cliente,
        desarrollado para trabajar solo bajo los entornos Windows®, OS X® y Linux®, se comunica con una aplicación
        web, manteniendo sincronizadas las etiquetas asociadas a los archivos ubicados en los repositorios del
        usuario, permitiéndole así clasificarlos y recuperarlos mediante el uso de palabras clave.
      @End @Section

      @Section
        @Title { Objetivos }
        @Tag { objetivos }
      @Begin
        @AddToIndex @Title { Objetivos } @Tag { objetivos }

        @BeginSubSections
          @SubSection
            @Title { Objetivo General }
            @Tag { obj.gen }
          @Begin
            @AddToIndex @Title { Objetivo General } @Tag { obj.gen }

            //2.0f @BulletList
              @ListItem {
                Desarrollar una herramienta web para la clasificación y recuperación de información
                digital basada en etiquetas
              }
            @EndList
          @End @SubSection

          @SubSection
            @Title { Objetivos Específicos }
            @Tag { obj.esp }
          @Begin
            @AddToIndex @Title { Objetivos Específicos } @Tag { obj.esp }

            //2.0f @BulletList
            @ListItem {
              Realizar una revisión documental sobre herramientas de clasificación y recuperación de
              información digital
            }
            @ListItem {
              Implementar la aplicación servidor para el almacenamiento y gestión de etiquetas de recursos
              digitales
            }
            @ListItem {
              Desarrollar el módulo de la aplicación cliente encargada del rastreo personalizable de la
              información a etiquetar
            }
            @ListItem {
              Desarrollar el módulo de la aplicación cliente correspondiente a la interfaz web de usuario
            }
            @ListItem {
              Realizar las pruebas de caja gris de la herramienta
            }
            @EndList
          @End @SubSection
        @EndSubSections
      @End @Section
    @EndSections
  @End @Chapter

  @NP

  @Chapter
    @Num { II }
    @Title { Marco Teórico }
  @Begin
    @BeginSections
      @Section
        @Title { Antecedentes de la Investigación }
        @Tag { antecedentes }
      @Begin
        @AddToIndex @Title { Antecedentes de la Investigación } @Tag { antecedentes }

        @PP
        En la actualidad, los sistemas de clasificación basados en etiquetas son ampliamente usados por
        innumerables aplicaciones web, sin embargo, su uso como complemento a los sistemas de archivo modernos
        presenta una reducida gama de opciones, dentro de la cual se pueden mencionar:

        @BeginSubSections
          @SubSection
            @Title { Tags }
            @Tag { ant.tags }
          @Begin
            @AddToIndex @Title { Tags } @Tag { ant.tags }

            @PP
            Tags es una aplicación que permite etiquetar archivos y directorios en @I finder (explorador),
            correos electrónicos en @I Mail (gestor de emails), fotos en @I IPhoto (gestor de imágenes) y
            enlaces en @I Safari (navegador web); con el objetivo de mantener organizados dichos recursos y
            poder hallarlos de manera rápida y sencilla.
            @PP
            Tags también ofrece una vista previa de la información, atajos de teclado y una excelente
            integración con el sistema operativo. Desafortunadamente, esta aplicación solo está disponible
            para el sistema operativo @I { OS X }®, está sujeta a una licencia privativa y no es capaz de
            sincronizar recursos localizados en diferentes dispositivos.

            //2.0f @AddFigure
              @Title { Imagen 1. Tags }
              @ImgSrc { "./include/img/tags.eps" }
              @ScaleXY { 0.4 0.28 }
              @Src { CASEapps (2014) }
          @End @SubSection

          @SubSection
            @Title { Taggtool }
            @Tag { ant.taggtool }
          @Begin
            @AddToIndex @Title { Taggtool } @Tag { ant.taggtool }

            @PP
            Taggtool permite añadir etiquetas a archivos, directorios y «bookmarks». Adicionalmente, el
            usuario puede proporcionar una descripción del recurso, además de una calificación cuantitativa
            (@I rating). Esta herramienta ofrece la posibilidad de importar metadatos pre-existentes en la
             información gestionada y realizar búsquedas en base a estos.
            @PP
            Taggtool también posee una alta integración con el sistema operativo y brinda una vista previa de los
            recursos gestionados. Además, facilita un sistema de etiquetado automático basado en la naturaleza de
            la información, y muestra una nube de etiquetas para la visualización de las mismas.
            @PP
            Al igual que Tags, Taggtool está sujeto a una licencia privativa y no es capaz de sincronizar
            recursos localizados en diferentes dispositivos. Otra desventaja que presenta esta herramienta
            es que está disponible solo para el sistema operativo @I { Microsoft Windows }®.

            //2.0f @AddFigure
              @Title { Imagen 2. Taggtool }
              @ImgSrc { "./include/img/taggtool.eps" }
              @ScaleXY { 0.4 0.4 }
              @Src { Taggtool (2014) }
          @End @SubSection

          @SubSection
            @Title { Tabbles }
            @Tag { ant.tabbles }
          @Begin
            @AddToIndex @Title { Tabbles } @Tag { ant.tabbles }

            @PP
            Tabbles ofrece la posibilidad de clasificar, buscar, organizar y compartir (a través de una LAN
            o la Internet) archivos, carpetas y «bookmarks», mediante el uso de etiquetas. Adicionalmente,
            la herramienta ofrece un sistema de auto-etiquetado, además de una excelente integración con el
            sistema operativo.
            @PP
            A pesar de ser capaz de gestionar, compartir y sincronizar recursos localizados en dispositivos
            distintos, Tabbles está disponible únicamente para el sistema operativo @I { Microsoft Windows }®
            bajo una licencia privativa.

            //2.0f @AddFigure
              @Title { Imagen 3. Tabbles }
              @ImgSrc { "./include/img/tabbles.eps" }
              @ScaleXY { 0.6  0.5 }
              @Src { Tabbles (2014) }
          @End @SubSection
        @EndSubSections
      @End @Section

      @Section
        @Title { Bases Teóricas }
        @Tag { bases.teoricas }
      @Begin
        @AddToIndex @Title { Bases Teóricas } @Tag { bases.teoricas }

        @BeginSubSections
          @SubSection
            @Title { Sistema de Archivo }
            @Tag { sis.arch }
          @Begin
            @AddToIndex @Title { Sistema de Archivo } @Tag { sis.arch }

            @PP
            Un sistema de archivo es un módulo central de todo sistema operativo moderno que consiste en
            estructuras lógicas y rutinas que controlan la creación, modificación, eliminación y acceso a los
            datos que residen en una unidad de disco, partición o volumen lógico. Dicho sistema organiza los
            datos en una estructura jerárquica mediante el uso de directorios, los cuales fungen como
            contenedores de punteros a múltiples archivos (EMC, 2012). Algunos de los sistemas de archivo más
            ampliamente usados en la actualidad son: FAT, FAT32, NTFS, HFS Plus, ext2, ext3 y ext4.
          @End @SubSection

          @SubSection
            @Title { Transparencia de Localización }
            @Tag { trans.loca }
          @Begin
            @AddToIndex @Title { Transparencia de Localización } @Tag { trans.loca }

            @PP
            Se refiere a una consideración de diseño de los sistemas operativos distribuidos. Se habla de
            transparencia de localización cuando un usuario accede a un recurso en particular sin que sea
            necesario conocer la ubicación del mismo dentro de la red de trabajo. El no conocer la
            localización de un recurso implica que todo acceso a éste es realizado por medio de un nombre que
            no depende de la ubicación dónde reside actualmente, ni la ubicación dónde éste fue creado
            (Borghoff y Schlichter, 2000).
          @End @SubSection

          @SubSection
            @Title { Aplicación Web }
            @Tag { web.app }
          @Begin
            @AddToIndex @Title { Aplicación Web } @Tag { web.app }

            @PP
            Es una aplicación desarrollada mediante el uso de tecnologías web (HTML, CSS, JavaScript, entre otros)
            cuyo entorno de ejecución (@I{ runtime enviroment }) está conformado por un motor web (@I{ web engine }).
            Como ejemplos de este tipo de aplicaciones se pueden mencionar: sistemas de reservación, sitios de
            compras en línea, juegos, aplicaciones multimedia, mapas, aplicaciones interactivas de diseños,
            sistemas de correo, entre otros (W3C, 2012).

            @PP
            Los cuatros componentes típicos de una aplicación web son: un navegador, un servidor web, programas de
            aplicación y un servidor de base de datos. Las responsabilidades del navegador incluyen: presentar una
            interfaz de usuario, comunicarse con un servidor web, ejecutar @I{ scripts } embebidos, gestionar la
            @I{ cache } y las @I{ cookies }. El servidor web se encarga, entre otras cosas, de comunicarse con los
            clientes, proveer contenido estático, invocar programas de aplicación para la generación de contenido
            dinámico y gestionar las conexiones (Grove, 2009).

            @PP
            @I{ CGI }, @I{ servlets }, lenguajes de plantilla (@I{ template languages }) y lenguajes de guión
            (@I{ script languages }) son algunos de los entornos de desarrollo para la construcción de los
            programas de aplicación mencionados anteriormente, y que están típicamente acompañados por un
            sistema de gestión de base de datos relacional (@I{ RDBMS }, por sus siglas en inglés) accedido
            por los programas de aplicación a través de un @I{ ODBC } "/" @I{ ORM } (Grove, 2009).
          @End @SubSection

          @SubSection
            @Title { ORM }
            @Tag { orm }
          @Begin
            @AddToIndex @Title { ORM } @Tag { orm }

            @PP
            Es una herramienta que permite conectar un objeto con una base de datos relacional de manera
            automática mediante el uso de metadatos como descriptores de dicho objeto. Algunas de las ventajas
            que ofrece el uso de un ORM sobre otras técnicas de acceso de datos se listan a continuación: en
            primer lugar, se automatiza la conversión bidireccional entre objetos y tablas; se provee el
            almacenamiento en @I{ cache } de los datos de manera transparente en el lado de la aplicación,
            mejorando así el rendimiento del sistema; y se brinda una @I API de acceso, abstrayendo por
            completo el sistema de gestión de bases de datos relacional (Mehta, 2008). @I{ ODB }, @I{ JDBC },
            @I{ Peewee }, @I{ SQLAlchemist } y @I{ Yii } son algunos de los ORM usados en la actualidad.
          @End @SubSection

          @SubSection
            @Title { AJAX }
            @Tag { ajax }
          @Begin
            @AddToIndex @Title { AJAX } @Tag { ajax }

            @PP
            Es una tecnología empleada para prevenir la carga de una página en su totalidad al permitir la
            transferencia de datos entre el cliente y el servidor web de manera asíncrona, logrando que las páginas
            se carguen más rápidamente al retrasar la descarga de grandes recursos (Zakas, 2010).
          @End @SubSection

          @SubSection
            @Title { JSON }
            @Tag { json }
          @Begin
            @AddToIndex @Title { JSON } @Tag { json }

            @PP
            Es un formato ligero y de fácil análisis sintáctico basado en la sintaxis dispuesta para los
            literales de tipo arreglo y objeto en el lenguaje de programación JavaScript. JSON es empleado
            generalmente para transmitir información entre distintos sistemas de software (Zakas, 2010). La
            serialización de información estructurada, tarea que se solía realizar comúnmente con XML, es
            actualmente llevada a cabo de manera frecuente mediante el uso del formato JSON.
          @End @SubSection

          @SubSection
            @Title { WSGI }
            @Tag { wsgi }
          @Begin
            @AddToIndex @Title { WSGI } @Tag { wsgi }

            @PP
            Es una interfaz simple y universal entre servidores y aplicaciones web para el lenguaje de programación
            Python (Eby, 2010). En términos simples, esta especificación establece la CGI (@I{ Common Gateway Interface })
            para el lenguaje de programación Python.
          @End @SubSection
        @EndSubSections
      @End @Section

      @Section
        @Title { Descripción de las Herramientas Usadas }
        @Tag  { herramientas.usadas }
        @Begin
          @AddToIndex @Title { Descripción de las Herramientas Usadas } @Tag  { herramientas.usadas }

        //2.0f @BulletList
          @ListItem {
            Python: es un lenguaje de programación interpretado y de propósito general que combina los paradigmas:
            orientado a objetos, imperativo y funcional. El dominio de aplicación del lenguaje va desde el
            desarrollo de herramientas y utilidades para la administración de sistemas y la construcción de páginas
            web ricas en características hasta la integración de componentes escritos en distintos lenguajes de
            programación, su uso en computación numérica y científica, el desarrollo de video juegos y la minería
            de datos (Lutz, 2010).
          }

          @ListItem {
            Flask: es un @I{ microframework } web para el lenguaje de programación Python. Su principal
            característica recae en poseer un conjunto de funcionalidades reducido y simple, brindando gran detalle
            a la extensibilidad de la herramienta, permitiéndole al usuario elegir los componentes a integrar,
            adaptándose así a las necesidades del proyecto a desarrollar y a las preferencias de los usuarios de
            manera flexible e indolora (Flask.org, 2014).
          }

          @ListItem {
            Pewee: es un ORM simple, escrito en python, que provee una interfaz ligera para realizar consultas SQL
            (Leifer, 2014).
          }

          @ListItem {
            SQLite: es una librería que implementa un motor de base de datos SQL transaccional y auto contenido.
            Sobresale entre sus características el poseer una arquitectura que no concibe la existencia de un
            proceso servidor, almacenando los datos gestionados en un archivo ordinario (SQLite.org, 2014).
          }

          @ListItem {
            Twitter bootstrap: es un @I{ framework } HTML, CSS y JavaScript para desarrollar proyectos web
            adaptables (@I{ responsive }) y orientados a dispositivos móviles (@I{ mobile first })
            (getbootstrap.com, 2014).
          }

          @ListItem {
            JQuery: es una librería escrita en JavaScript rápida, simple y con una gran repertorio de utilidades.
            Hace de la manipulación del DOM, el manejo de eventos, la creación de animaciones y el uso de Ajax,
            tareas mucho más sencillas de realizar a través de una @I API multiplataforma (JQuery.com, 2014).
          }
        @EndList
      @End @Section
    @EndSections
  @End @Chapter

  @NP

  @Chapter
    @Num { III }
    @Title { Marco Metodológico }
  @Begin
    @BeginSections
      @Section
        @Title { Descripción de la Metodología Empleada }
        @Tag { desc.met }
      @Begin
        @AddToIndex @Title { Descripción de la Metodología Empleada } @Tag { desc.met }

        @PP
        Para el desarrollo de la herramienta, fruto de esta investigación, se empleó la metodología @I{ Scrum }, la
        cual es definida por sus autores como un ``marco de trabajo en el cual las personas abordan problemas
        adaptativos complejos, entregando productos del más alto valor posible de manera productiva y creativa''
        (Schwaber y Sutherland, 2011).

        @PP
        @I{ Scrum } está fundamentada en el empirismo, el cual afirma que el conocimiento viene de la
        experiencia y que la toma de decisiones debe basarse en lo que se sabe. También, vale mencionar que esta
        metodología emplea un modelo iterativo e incremental para optimizar la capacidad de predicción y el control
        de riesgos.

        @PP
        El corazón del @I{ Scrum } es el @I{ Sprint }, el cual es un lapso de tiempo, cuya duración no supera la de
        un mes, durante el cual un incremento de un producto terminado, usable y potencialmente entregable es
        creado. Un @I{ Sprint } abarca lo que se va a construir, la elaboración de un plan flexible para llevar a
        cabo dicho proceso, la construcción en sí misma y el producto resultante.

        @PP
        En cuanto a las pruebas del sistema, se optó por la aplicación de dos tipos: pruebas funcionales orientadas
        a tareas (@I{ Task-Oriented Functional Tests }) y pruebas de errores forzados (@I{ Forced-Error Tests }),
        ambas ejecutadas bajo el modelo de caja gris.

        @PP
        De acuerdo a Hung Nguyen, Bob Johnson y Michael Hackett, las pruebas funcionales orientadas a tareas
        consisten de casos de prueba positivos que son diseñados para verificar las características del programa al
        asegurarse de que cada una de ellas se comporte como se espera, tomando en cuenta las especificaciones,
        guías de usuario, requerimientos y documentos de diseño. Cada funcionalidad es puesta a prueba para:

        //2.0f @BulletList indent { 4s }
          @ListItem {
            Validar que la tarea se lleva a cabo con condiciones de datos soportados bajo condiciones
            operativas favorables.
          }
          @ListItem {
            Verificar la integridad del resultado final de la tarea.
          }
          @ListItem {
            Asegurar la integridad de la funcionalidad cuando se usa junto a otras.
          }
        @EndList

        @PP
        Por su parte, las pruebas de errores forzados, según Nguyen, Johnson y Hackett, son casos de prueba
        negativos diseñados para forzar a un programa a pasar a una condición de error. Debe generarse una lista de
        todos los mensajes de error que el programa emite, la cual es usada como base en el desarrollo de casos
        de prueba. Algunas recomendaciones a la hora de llevar a cabo este tipo de pruebas se describen a
        continuación:

        //2.0f @BulletList indent { 4s }
          @ListItem {
            Verificar que todas las condiciones de error comunes sean detectadas y manejadas correcta y
            consistentemente.
          }
          @ListItem {
            Verificar que el programa se recupere correctamente para toda condición de error.
          }
          @ListItem {
            Verificar que los estados inestables del programa, causados por un error, también sean corregidos.
          }
        @EndList

        @PP
        Por su parte, el modelo (o pruebas, como también es conocido) de caja gris incorpora elementos de las
        pruebas de caja negra y blanca. En las pruebas de caja gris se considera el resultado desde el punto de
        vista del usuario, el conocimiento técnico específico del sistema y el ambiente operativo; además, estas
        pruebas evalúan el diseño de la aplicación bajo el contexto de la interoperabilidad entre los componentes
        del sistema.

        @PP
        El modelo de caja gris es ideal para poner a prueba de manera efectiva aplicaciones web debido a que
        éstas abarcan numerosos componentes, tanto de software como de hardware. Estos componentes deben ser
        probados en el contexto del diseño del sistema para evaluar su funcionalidad y compatibilidad.
      @End @Section

      @Section
        @Title { Desarrollo de la Herramienta Bajo la Metodología Scrum }
        @Tag { desarr.met }
      @Begin
        @AddToIndex @Title { Desarrollo de la Herramienta Bajo la Metodología Scrum } @Tag { desarr.met }

        @PP
        El desarrollo de la herramienta web, @I Omnitag, se llevó a cabo a lo largo de nueve @I{ Sprints }, cada uno
        de un mes de duración. La distribución de las tareas llevadas a cabo a lo largo del ciclo de desarrollo se
        ha plasmado en la siguiente tabla; la descripción de las mismas se plantea justo después de la mencionada
        ésta.

        @NP

        //2.0f @MyCenter @B { Tabla 1. Distribución de Actividades }
        //0f @PageMark { dist.act }
        //0f @AddToTIndex @Title { Tabla 1. Distribución de Actividades } @Tag { dist.act }
        //0f @CD { 0.36 0.32 } @Scale @IncludeGraphic "./include/img/tabla1.eps"
        //0f @MyCenter @B { Fuente: Fuente propia }

        @BeginSubSections
          @SubSection
            @Title { Primer Sprint }
            @Tag { sp.1 }
          @Begin
            @AddToIndex @Title { Primer Sprint } @Tag { sp.1 }

            @PP
            Durante este @I{ sprint } se culminó la revisión de la literatura relacionada con los sistemas de
            clasificación y recuperación de información digital basados en etiquetas, con la recopilación de los
            antecedentes de esta investigación. Además, se comenzó a diseñar e implementar la interfaz web de usuario
            a través del diseño de bocetos físicos y digitales; y la base de datos, mediante el esquema fundamental
            de la misma. Adicionalmente, se dio inicio al proceso de codificación e implementación de la aplicación
            servidor, diseñando la funcionalidad base para recibir y responder peticiones HTTP. Todo esto junto a las
            respectivas pruebas de caja gris de los componentes desarrollados, acción que se mantuvo durante todo el
            ciclo de desarrollo de la herramienta.
          @End @SubSection

          @SubSection
            @Title { Segundo Sprint }
            @Tag { sp.2 }
          @Begin
            @AddToIndex @Title { Segundo Sprint } @Tag { sp.2 }

            @PP
            Durante este @I{ sprint } se continuó con las actividades iniciadas en el anterior, refinando el diseño
            de la base de datos, añadiendo nuevas características a la aplicación servidor y mejorando la interfaz
            web de usuario con el fin de hacerla más intuitiva y funcional.
          @End @SubSection

          @SubSection
            @Title { Tercer Sprint }
            @Tag { sp.3 }
          @Begin
            @AddToIndex @Title { Tercer Sprint } @Tag { sp.3 }

            @PP
            Al igual que en el anterior, durante este @I{ sprint } se dio continuidad a las labores anteriormente
            descritas, añadiendo un nuevo conjunto de características a la aplicación servidor, reflejando estas
            mejoras en la interfaz web del usuario y dándole los toques finales a la base de datos, finalizando el
            proceso de diseño e implementación de la misma.
          @End @SubSection

          @SubSection
            @Title { Cuarto Sprint }
            @Tag { sp.4 }
          @Begin
            @AddToIndex @Title { Cuarto Sprint } @Tag { sp.4 }

            @PP
            En este @I{ Sprint } se comenzó el diseño de una @I API pública, implementada en la aplicación
            servidor, para permitir una comunicación sencilla con la misma, potenciando así la posibilidad de
            desarrollar una aplicación cliente que se comunique con el servidor de manera efectiva. También se
            hicieron un par de cambios menores a la interfaz web de usuario.
          @End @SubSection

          @SubSection
            @Title { Quinto Sprint }
            @Tag { sp.5 }
          @Begin
            @AddToIndex @Title { Quinto Sprint } @Tag { sp.5 }

            @PP
            Es en este @I{ Sprint } que se dio inicio a la codificación e implementación de la aplicación cliente,
            conformada, al final de este ciclo, solo por el mecanismo de rastreo de recursos del sistema. Por otro
            lado, se expandió la @I API mencionada anteriormente y se continuó el proceso de refinamiento de la
            interfaz web de usuario, acciones que se repiten hasta el final del séptimo @I { Sprint }.
          @End @SubSection

          @SubSection
            @Title { Sexto Sprint }
            @Tag { sp.6 }
          @Begin
            @AddToIndex @Title { Sexto Sprint } @Tag { sp.6 }

            @PP
            Se desarrolló el módulo que permite al usuario seleccionar a potestad cuáles directorios serán
            incluidos en el proceso de rastreo, así como el módulo que se encarga de mantener sincronizada con el
            servidor la información generada a partir de dicho rastreo.
          @End @SubSection

          @SubSection
            @Title { Séptimo Sprint }
            @Tag { sp.7 }
          @Begin
            @AddToIndex @Title { Séptimo Sprint } @Tag { sp.7 }

            @PP
            A lo largo de este sprint, se implementó la gestión de usuarios en la aplicación servidor, se adaptó la
            interfaz para reflejar dichos cambios y se implementó en ambas aplicaciones un mecanismo de
            comunicación sencillo, robusto y seguro, basado en @I{ tokens }.
          @End @SubSection

          @SubSection
            @Title { Octavo Sprint }
            @Tag { sp.8 }
          @Begin
            @AddToIndex @Title { Octavo Sprint } @Tag { sp.8 }

            @PP
            Durante este @I{ Sprint } se desarrolló e integró un mecanismo de etiquetado automático de la
            información rastreada.
          @End @SubSection

          @SubSection
            @Title { Noveno Sprint }
            @Tag { sp.9 }
          @Begin
            @AddToIndex @Title { Noveno Sprint } @Tag { sp.9 }

            @PP
            Durante este @I Sprint se llevaron a cabo las pruebas más rigurosas del sistema, con la finalidad
            de detectar y posteriormente corregir errores funcionales que se encontrasen en la aplicación,
            cerrando así el ciclo de desarrollo de esta investigación.
          @End @SubSection
        @EndSubSections
      @End @Section
    @EndSections
  @End @Chapter

  @NP

  @Chapter
    @Num { IV }
    @Title { OmniTag }
  @Begin
    @BeginSections
      @Section
        @Title { Arquitectura de la Herramienta }
        @Tag { arc.herr }
      @Begin
        @AddToIndex @Title { Arquitectura de la Herramienta } @Tag { arc.herr }

        @PP
        @I OmniTag es una herramienta que permite a sus usuarios organizar y buscar los archivos, contenidos en sus
        distintos computadores de escritorio y portátiles, a través del uso de etiquetas bajo una sola plataforma
        basada en tecnologías web y el lenguaje de programación Python.

        @PP
        @I OmniTag relega a un navegador web el despliegue de su interfaz gráfica de usuario, construida mediante el
        uso de los lenguajes HTML y CSS junto al @I{ framework } Twitter Bootstrap, para la parte visual; y el
        lenguaje de programación JavaScript, con la ayuda de la librería JQuery, para la parte interactiva. La lógica
        de negocios es manejada por el interprete de Python, el cual se vale de una base de datos SQLite para
        gestionar la información no volátil, base de datos con la que interactúa mediante el ORM Peewee; y el
        @I{ framework } web Flask, encargado del manejo de las peticiones web, la transmisión de contenido estático,
        la ejecución de los programas de aplicación para generar contenido dinámico, entre otros.

        @PP
        Funcionalmente, @I OmniTag está constituida por dos módulos fundamentales: uno cliente y otro servidor. Ambos
        módulos dependen de un navegador web para interactuar con el usuario, haciendo uso de las tecnologías
        disponibles en dicho navegador para desplegar una interfaz interoperable.

        @PP
        El módulo servidor se ocupa de la gestión de todos los procesos relacionados con la creación, control y
        mantenimiento de los usuarios y sus correspondientes dispositivos. También se encarga de brindar las
        funcionalidades de visualización, etiquetado y búsqueda de los recursos almacenados en dichos dispositivos.
        La tarea de visualización se ofrece al usuario empleando una capa de transparencia de localización para un
        cómodo tratamiento de los recursos; el etiquetado es flexible, pudiendo aplicar o remover etiquetas a
        múltiples recursos a la vez, y la búsqueda es un proceso intuitivo permitiendo asociar un número arbitrario
        de palabras clave bajo un mismo término con el fin de potenciar, facilitar y agilizar la recuperación de
        la información gestionada.

        @PP
        Por su parte, el módulo cliente es la pieza destinada a residir en los dispositivos de los usuarios,
        permitiendo a éstos indicarle cuáles directorios de un repositorio en particular tomará en cuenta a la hora
        de rastrear los recursos que serán sincronizados con el módulo servidor para su posterior clasificación y
        recuperación. También es responsable de alojar los parámetros de configuración empleados en la comunicación
        con el servidor, además de ser el encargado de predefinir etiquetas a un subconjunto de los archivos
        rastreados dependiendo de la naturaleza de los mismos. La Imagen 4 plasma la funcionalidad de estos
        módulos, así como la interacción que se da entre ellos y aquella que involucra al usuario.

        //2.0f @AddFigure
          @Title { Imagen 4. Arquitectura Funcional de la Herramienta }
          @ImgSrc { "./include/img/arquitectura-funcional.eps" }
          @ScaleXY { 0.6 0.52 }
          @Src { Fuente propia }
      @End @Section

      @Section
        @Title { Implementación de la Herramienta }
        @Tag { impl.herr }
      @Begin
        @AddToIndex @Title { Implementación de la Herramienta } @Tag { impl.herr }

        @PP
        La Imagen 5 ilustra los modelos que forman parte del módulo servidor, cabe mencionar que ésta
        describe los atributos de los modelos y las relaciones que existen entre ellos tomando en cuenta su
        representación en forma de tablas bajo un paradigma relacional, estando éstas intrínsecamente vinculadas
        con sus correspondientes clases (paradigma orientado a objetos) mediante el uso de @I{ Peewee } (ORM).
        Estos modelos son:

        //2.0f @BulletList indent { 4s }
          @ListItem { User: Representa un usuario de la herramienta. }
          @ListItem { Device: Representa un dispositivo de un usuario. }
          @ListItem { Tag: Representa una etiqueta, la cual pertenece a un único usuario. }
          @ListItem { Resource: Representa un recurso alojado en un dispositivo en particular. }
          @ListItem { Search: Representa asociaciones de etiquetas usadas en búsquedas almacenadas. }
        @EndList

        //2.0f @AddFigure
          @Title { Imagen 5. Diagrama de Clases de los Modelos }
          @ImgSrc { "./include/img/classes-serv.eps" }
          @ScaleXY { 0.4 0.5 }
          @Src { Fuente propia }

        @PP
        Como puede observarse, los modelos comparten una interfaz común, definida por la clase @I BaseModel,
        además de tener asociados un conjunto de métodos, a saber:

        //2.0f @BulletList indent { 4s }
          @ListItem {
            @I{ BaseModel }: Pauta la interfaz mínima que debe poseer todo modelo, definiendo tres métodos:
            @I{ exists }, para verificar la existencia de un registro en particular en la base de datos
            correspondiente; @I{ get_by_id }, que retorna un conjunto de registros dada una lista de
            identificadores; y por último, @I{ json }, el cual se encarga de convertir en formato @I{ JSON } un
            registro en particular.
          }
          @ListItem {
            @I{ Tag }: Solo define un método: @I{ get_by_name }, que se encarga de devolver todos aquellos
            registros que correspondan a una lista de nombres en particular.
          }
          @ListItem {
            @I{ Search }: Similar a @I{ Tag }, esta clase define solo un método @I{ get_by_name }, el cual, a
            partir de una lista de nombres, retorna todos los recursos cuyo nombre se encuentra en la mencionada
            lista.
          }
          @ListItem {
            @I{ Resource }: Esta clase define un método llamado @I{ get_untagged_resources } que se encarga de
            devolver todos aquellos recursos que no poseen asociación alguna con una etiqueta.
          }
          @ListItem {
            @I{ TagSearch }: Establece la relación que existe entre las etiquetas y las búsquedas. Esta clase
            ofrece un método @I{ get_tags_by_search } que retorna todas las etiquetas asociadas a una búsqueda en
            particular.
          }
          @ListItem {
            @I{ TagResource }: Funge como vínculo entre las etiquetas y los recursos. El método @I{
            get_resources_by_tag } permite obtener todos los recursos que se encuentran asociados a un conjunto
            arbitrario de etiquetas.
          }
        @EndList

        @PP
        En el caso del módulo cliente, se presenta a continuación un diagrama de clases que muestra la estructura
        interna del mismo.

        //2.0f @AddFigure
          @Title { Imagen 6. Diagrama de Clases del Módulo Cliente }
          @ImgSrc { "./include/img/classes-clnt.eps" }
          @ScaleXY { 0.4 0.42 }
          @Src { Fuente propia }

        //2.0f @BulletList indent { 4s }
          @ListItem {
            @I{ Manager }: se encargar de la generación, lectura y respaldo de los archivos de configuración y
            estado del sistema, así como también de la comunicación con el módulo servidor. Los métodos asociados a
            esta clase son: @I{ __backup_thread } y @I{ __sync_thread } contienen los hilos que se encargan del
            respaldo de las variables de estado y la sincronización de los archivos rastreados con el servidor,
            respectivamente; @I{ start_backup_daemon } y @I{ start_sync_daemon } se encargan de ejecutar los hilos
            mencionados anteriormente; @I{ __add_to_black_list } y @I{ __add_to_white_list } controlan la inserción
            de directorios en la lista negra y blanca, de manera
            correspondiente.
          }
          @ListItem {
            @I{ DaemonThread }: es la clase usada para generar los hilos de ejecución asíncrona y que extiende a la
            clase @I{ Thread } del módulo @I{ threading } de la librería estándar del lenguaje de programación
            Python.
          }
          @ListItem {
            @I{ Cache }: es la clase sobre la cual @I{ Manager } confía las tareas de respaldo de las variables de
            estado. Los métodos definidos en esta clase son: @I{ __check_all }, @I{ __check_integrity } y
            @I{ __check_state }, empleados para verificar la integridad del estado interno de toda instancia de la
            clase; @I{ __get_default_base_dir } retorna el directorio base a usar por defecto; @I{ __load } carga
            en memoria las variables de estado serializadas en el medio de almacenamiento secundario del
            dispositivo en formato JSON; @I{ dump }, lleva a cabo el proceso inverso que realiza @I{ __load }; y,
            por último, los métodos @I{ get } y @I{ set } controlan el acceso y redefinición de las variables
            respaldadas.
          }
          @ListItem {
            @I{ SyncAgent }: es usada por la clase @I{ Manager } para mantener los archivos rastreados en
            sincronización con el servidor. Los métodos de esta clase son: @I{ __build_request } construye una
            petición HTTP a partir de una lista de archivos, petición usada por la conexión generada por
            @I{ __build_connection }; el método @I{ sync } lleva a cabo la sincronización mediante el uso de la
            conexión mencionada anteriormente.
          }
          @ListItem {
            @I{ Crawler }: encapsula las rutinas relacionadas con el rastreo de recursos en el dispositivo del
            usuario. Los métodos definidos es esta clase son los siguientes: @I{ __check_state } verifica la
            integridad del estado interno de toda instancia de la clase; @I{ __crawl_directory } determina, dada
            la ruta de un directorio, si éste debe o no ser tomado en cuenta en el rastreo de archivos; y, por
            último, @I{ crawl } ejecuta el rastreo.
          }
          @ListItem {
            @I{ AutoTagger }: esta clase se encarga de relacionar etiquetas a los archivos rastreados de manera
            automática en función de la extensión de éstos. El único método de esta clase se llama @I{ process },
            el cuál ejecuta el etiquetado automático de los archivos indicados.
          }
          @ListItem {
            @I{ SettingsForm }: es empleada para la recepción y validación de los parámetros de configuración
            proporcionados por los usuarios a través de la interfaz gráfica. Los métodos definidos en esta clase se
            describen a continuación: @I{ validate } verifica la integridad de la información enviada por el
            usuario y @I{ update_setings } se encarga de comunicar al resto de la aplicación los nuevos valores de
            los parámetros de configuración.
          }
        @EndList

        @PP
        A continuación, se presenta el pseudo-código de los procesos de rastreo y auto-etiquetado de archivos,
        componentes más sobresalientes del sistema:

        //2.0f @AddFigure
          @Title { Imagen 7. Crawler }
          @ImgSrc { "./include/img/crawler.eps" }
          @ScaleXY { 0.5 0.4 }
          @Src { Fuente propia }

        //2.0f @AddFigure
          @Title { Imagen 8. AutoTagger }
          @ImgSrc { "./include/img/auto-tagger.eps" }
          @ScaleXY { 0.5 0.4 }
          @Src { Fuente propia }
      @End @Section
    @EndSections
  @End @Chapter

  @NP
  
  @Chapter
    @Num { V } 
    @Title { Pruebas del Sistema }
  @Begin
    @BeginSections
      @Section
        @Title { Descripción de las pruebas realizadas }
        @Tag { desc.pruebas }
      @Begin
        @AddToIndex @Title { Descripción de las pruebas realizadas } @Tag { desc.pruebas }

        @PP
        La fiabilidad del sistema fue verificada a través de la implementación de pruebas funcionales orientadas a
        tareas y pruebas de errores forzados bajo el modelo de caja gris, técnicas descritas en detalle en el
        capítulo III. El principal insumo de las pruebas realizadas lo conforma una estructura de directorios
        diseñada con el fin de representar un ambiente habitual de ejecución. A pesar de que las pruebas se
        llevaron a cabo en un ambiente Linux®, éstas se desarrollaron con total independencia del sistema operativo
        subyacente. A continuación, se ilustra la estructura de directorios en cuestión:

        //1v {
          { 1fx } @Break {
            0.8f @Font @F "cat test-dir-structure.txt" @PipeVerbatim {}
          }
        }

        @PP
        El sistema fue puesto a prueba desde la perspectiva del usuario, proporcionando a la herramienta tanto
        información correctamente formada (pruebas funcionales orientadas a tareas) como información inesperada
        (pruebas de errores forzados), verificando así el adecuado comportamiento de las distintas funcionalidades
        que éste ofrece, además de constatar su capacidad de recuperarse ante un estado de error y advertir al
        usuario de dicho suceso.

        @PP
        En primer lugar, se puso a prueba el mecanismo de la aplicación servidor para el registro de un nuevo
        usuario. En la Imagen 9 se muestra comportamiento presentado por la herramienta ante el inicio
        de sesión de un usuario inexistente (A), el registro de un nuevo usuario mediante el ingreso
        heterogéneo de la contraseña y su verificación (B), el registro de un usuario efectivo del sistema (C)
        y el registro exitoso de un nuevo usuario (D).

        //2.0f @AddFigure
          @Title { Imagen 9. Pruebas del registro de un nuevo usuario }
          @ImgSrc { "./include/img/resultados/registro.eps" }
          @ScaleXY { 0.42 0.46 }
          @Src { Fuente propia }

        @PP
        De manera similar, se verificó la funcionalidad que permite adicionar un nuevo dispositivo de usuario
        (A), obtener el @I token del nuevo dispositivo (B), proporcionar y modificar el nombre y apellido del
        usuario (D), y visualizar el @I token del usuario (C). El resultado de las pruebas anteriormente
        descritas se muestra en la Imagen 10.

        //2.0f @AddFigure
          @Title { Imagen 10. Pruebas del registro de un nuevo dispositivo }
          @ImgSrc { "./include/img/resultados/tokens.eps" }
          @ScaleXY { 0.42 }
          @Src { Fuente propia }

        @PP
        En la Imagen 11, se exhibe la ventana principal de la aplicación cliente, plasmando el
        comportamiento presentado por ésta ante la introducción de datos erróneos para los parámetros de
        configuración.

        //2.0f @AddFigure
          @Title { Imagen 11. Pruebas de los parámetros de configuración de la aplicación cliente }
          @ImgSrc { "./include/img/resultados/client-settings.eps" }
          @ScaleXY { 0.42 0.38 }
          @Src { Fuente propia }

        @PP
        Se presenta en la Imagen 12 el resultado de las pruebas ejecutadas al mecanismo de lista negra
        (A) y blanca (B y C) integrado en la aplicación cliente, mecanismo que permite delimitar los
        directorios a gestionar.

        //2.0f @AddFigure
          @Title { Imagen 12. Pruebas de la lista blanca y negra de directorios a rastrear }
          @ImgSrc { "./include/img/resultados/wb-lists.eps" }
          @ScaleXY { 0.48 0.42 }
          @Src { Fuente propia }

        @PP
        En las dos siguiente imágenes se puede apreciar el resultado de la sincronización realizada entre la
        aplicación cliente y servidor, además de visualizar los vínculos establecidos de manera automática
        entre los archivos recién gestionados y un conjunto de etiquetas predefinidas (@I video, @I data, @I
        document, @I image, @I music y @I presentation).

        //2.0f @AddFigure
          @Title { Imagen 13. Pruebas de sincronización de archivos y etiquetado automático (I) }
          @ImgSrc { "./include/img/resultados/tagged-files-I.eps" }
          @ScaleXY { 0.42 }
          @Src { Fuente propia }

        //2.0f @AddFigure
          @Title { Imagen 14. Pruebas de sincronización de archivos y etiquetado automático (II) }
          @ImgSrc { "./include/img/resultados/tagged-files-II.eps" }
          @ScaleXY { 0.42 0.44 }
          @Src { Fuente propia }

        @PP
        Continuando con las pruebas anteriores, se comprobó el funcionamiento de la opción @I {Unttaged
        files}, la cual muestra aquellos archivos que no están vinculados a ninguna etiqueta. El
        comportamiento de esta funcionalidad se muestra a continuación:

        //2.0f @AddFigure
          @Title { Imagen 15. Prueba complementaria de la sincronización de archivos }
          @ImgSrc { "./include/img/resultados/untagged-files.eps" }
          @ScaleXY { 0.42 0.54 }
          @Src { Fuente propia }

        @PP
        La verificación realizada al mecanismo que permite crear una nueva etiqueta es detallada paso a paso
        en la Imagen 16, presentada a continuación:

        //2.0f @AddFigure
          @Title { Imagen 16. Pruebas de funcionalidad ``agregar nueva etiqueta'' }
          @ImgSrc { "./include/img/resultados/new-tag.eps" }
          @ScaleXY { 0.42 0.36 }
          @Src { Fuente propia }

        @PP
        Por último, la Imagen 17 muestra las pruebas realizadas a la funcionalidad que permite el
        guardado (A y B) de una búsqueda, además de la modificación del identificador de la misma (C).

        //2.0f @AddFigure
          @Title { Imagen 17. Pruebas de funcionalidad ``guardar nueva búsqueda'' }
          @ImgSrc { "./include/img/resultados/save.eps" }
          @ScaleXY { 0.42 0.36 }
          @Src { Fuente propia }

        @PP
        Como se pudo observar, todas las funcionalidades incorporadas en ambos módulos (cliente y servidor) del
        sistema presentan el comportamiento esperado tanto frente a datos correctos como incorrectos, mostrando en
        este último caso mensajes adecuados para la situación correspondiente y recuperándose de manera efectiva
        ante los fallos que se produjeron.
      @End @Section
    @EndSections
  @End @Chapter

  @NP

  @ExtraSection
    @Title { CONCLUSIONES }
    @AlterTitle { Conclusiones }
  @Begin
    @PP
    @I Omnitag, la herramienta producto de este trabajo de investigación, fue desarrollada con el objetivo de
    permitir la clasificación y recuperación de información digital mediante el uso de etiquetas. Este modelo de
    gestión de información se logró gracias a la implementación de una arquitectura cliente-servidor y al
    desarrollo apoyado en tecnologías web, factores que contribuyeron al aspecto centralizado y multiplataforma de
    la herramienta.

    @PP
    El proceso que concluyó con el nacimiento de @I Omnitag partió de la implementación de la aplicación servidor,
    cuya principal tarea es el almacenamiento y gestión de etiquetas y metadatos de recursos digitales. Los
    procesos de almacenamiento y gestión fueron garantizados mediante el empleo de una base de datos relacional y
    un servidor web, respectivamente.

    @PP
    El primero de los dos módulos que constituyen la aplicación cliente fue dispuesto para efectuar el rastreo
    personalizable de la información a etiquetar, manteniendo sincronizada dicha información con el servidor. El
    segundo módulo fue destinado a la interfaz gráfica del usuario, construida con la ayuda de los lenguajes HTML,
    CSS y JavaScript, con el fin de facilitar su despliegue en distintos sistemas operativos.

    @PP
    Finalmente, se sometió a @I OminiTag a una serie de pruebas mediante el modelo de caja gris, pruebas ejecutadas
    de manera exitosa y documentadas en detalle con el apoyo de una secuencia de capturas de pantalla
    para una mejor apreciación del comportamiento de la herramienta frente a las situaciones diseñadas en las
    pruebas.
  @End @ExtraSection

  @NP

  @ExtraSection
    @Title { RECOMENDACIONES }
    @AlterTitle { Recomendaciones }
  @Begin
    @PP
    Se recomienda implementar la herramienta en dispositivos móviles, así como también integrarla a los principales
    navegadores web para ofrecer a los usuarios la posibilidad de gestionar los archivos almacenados en teléfonos
    inteligentes y tabletas, y sincronizar sus @I bookmarks respectivamente.

    @PP
    Se sugiere el desarrollo de un módulo para el recabado y visualización de información estadística,
    abarcando información como cantidad y uso de etiquetas, además de la relación y topología derivada de su
    vínculo con los archivos gestionados.

    @PP
    Finalmente, se propone integrar la herramienta con un servicio web de alojamiento de archivos (Dropbox, Google
    Drive, Microsoft OneDrive, entre otros) con el fin de respaldar la información gestionada por @I OmniTag o
    efectuar la transferencia de la misma entre los dispositivos sincronizados a través de este tipo de servicio.
  @End @ExtraSection

  @NP

  @ExtraSection
    @Title { REFERENCIAS BIBLIOGRÁFICAS }
    @AlterTitle { Referencias bibliográficas }
  @Begin
    //0.85v
    Atkinson, R.C.; Shiffrin, R.M. (1968). Chapter: Human memory: A proposed system and its control
    processes. The psychology of learning and motivation. pp. 89-195.

    //0.85v
    Baddeley, A.D. (1966). The influence of acoustic and semantic similarity on long-term memory for word
    sequences. The Quarterly Journal of Experimental Psychology. pp. 302-309.

    //0.85v
    Borghoff, Uwe; Schlichter, Johann (2000). Computer-Supported Cooperative Work: Introduction to
    Distributed Applications. Springer Science y Business Media. p. 6.

    //0.85v
    Burgin, Mark (2010). Theory of Information: Fundamentality, Diversity and Unification. World Scientific.
    p. VI.

    //0.85v
    CASEapps (2014) (Página consultada el 16 de julio de 2014) [On-line]. Dirección: "http://www.caseapps.com/tags/"

    //0.85v
    Eby, Phillip (2010) (Página consultada el 16 de julio de 2014) [On-line]. Dirección:
    "http://legacy.python.org/dev/peps/pep-3333".

    //0.85v
    EMC Education Services (2012). Information Storage and Management: Storing, Managing, and Protecting
    Digital Information in Classic, Virtualized, and Cloud Environments. John Wiley "&" sons. p. 6.

    //0.85v
    Flask.org (2014)(Página consultada el 19 de julio de 2014) [On-line]. Dirección: "http://flask.pocoo.org/".

    //0.85v
    Furth, J. (1994). The Information Age in Charts, Fortune International.

    //0.85v
    getbootstrap.com (2014) (Página consultada el 19 de julio de 2014) [On-line]. Dirección:
    "http://getbootstrap.com/".

    //0.85v
    Giuliano, V.E. (1983). The United States of America in the Information Age, en Information Policy and
    Scientific Research, Elsevier, Amsterdam, pp. 59-76.

    //0.85v
    Grove, Ralph (2009). Web Based Application Development. Jones "&" Bartlett Publishers. p. 42.

    //0.85v
    IBM (2012) (Página consultada el 25 de junio de 2013) [On-line]. Dirección:
    "www-01.ibm.com/software/data/bigdata/"

    //0.85v
    JQuery.com (2014) (Página consultada el 19 de julio de 2014) [On-line]. Dirección: "http://jquery.com/".

    //0.85v
    Leifer, Charles (2014) (Página consultada el 19 de julio de 2014) [On-line]. Dirección:
    "http://peewee.readthedocs.org/".

    //0.85v
    Lutz, Mark (2010). Programming Python. O"'"Reilly Media, Inc.

    //0.85v
    Mathes, Adam (2004) (Página consultada el 25 de junio de 2013) [On-line]. Dirección:
    "www.adammathes.com/academic/computer-mediated-communication/folksonomies.html"

    //0.85v
    Mehta, Vijay (2008). Pro LINQ Object Relational Mapping in C"#" 2008. Apress. pp. 4-5.

    //0.85v
    Multics (1968) (Página consultada el 25 de junio de 2013) [On-line]. Dirección:
    "www.multicians.org/fjcc4.html"

    //0.85v
    Nguyen, Hung; Johnson, Bob; Hackett, Michael (2003). Testing Applications on the Web: Test Planning for
    Mobile and Internet-Based Systems. Second Edition. Wiley Publishing, Inc.

    //0.85v
    Schwaber, Ken; Sutherland, Jeff (2011). The Definitive Guide to Scrum: The Rules of the Game.

    //0.85v
    Specia, Lucia; Motta, Enrico (2007). Integrating Folksonomies with the Semantic Web. Knowledge Media
    Institute - The Open University.

    //0.85v
    SQLite.org (2014) (Página consultada el 19 de julio de 2014) [On-line]. Dirección:
    "https://sqlite.org/about.html".

    //0.85v
    Tabbles (2014) (Página consultada el 16 de julio de 2014) [On-line]. Dirección: "http://tabbles.net/"

    //0.85v
    Taggtool (2014) (Página consultada el 16 de julio de 2014) [On-line]. Dirección: "http://www.taggtool.com/"

    //0.85v
    W3C (2012) (Página consultada el 16 de julio de 2014) [On-line]. Dirección:
    "http://www.w3.org/2012/webapps/charter/"

    //0.85v
    Zakas, Nicholas (2010). High Performance JavaScript. O"'"Reilly Media, Inc.
  @End @ExtraSection
@End @TEG
@End @Text
