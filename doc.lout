@Include { "include/lib/licomteg.lout" }

@Doc @Text @Begin
@TEG
  @MyFirstName { Edinson }
  @MyLastName { Padrón Urdaneta }
  @MyIDNumber { 19.216.488 }
  @MyEmail { edinson.padron.urdaneta@gmail.com }
  @MyPhoneNumber { +58 414 6574149 }
  @MyAddress { Venezuela, Zulia, Maracaibo, Urb. La Paz, Calle 96D, Avenida 56 }
  @PaperTitle { Herramienta Web para la Clasificación y Recuperación de Información Digital Basada en Etiquetas }
  @IsReport { Y }
@Begin
  @Cover
    @Tutor { MSc. Gerardo Pirela Morillo }
    @Month { marzo }
    @Year { 2014 }

  @NP

  @Facade
    @TutorInfo {
      MSc. Gerardo Pirela Morillo @FF
      CI.: 12.404.565 @FF
      Teléfono: +58 412 1734718 @FF
      Correo electrónico: gepirela@fec.luz.edu.ve
    }

  @NP

  @Summary
    @KeyWords { Aplicación web, Etiquetado, Clasificación, Recuperación, Información digital }
  @Begin
    @PP
  @End @Summary

  @NP

  @Abstract
    @KeyWords { Web application, Tagging, Classification, Retrieval, Digital information }
  @Begin
    @PP
  @End @Abstract

  @NP

  @IndexOfContents

  @NP

  @IndexOfTables

  @NP

  @IndexOfGraphics

  @NP

  @ExtraSection
    @Title { INTRODUCCIÓN }
    @AlterTitle { Introducción }
  @Begin
    @PP

  @End @ExtraSection

  @NP

  @Chapter
    @Num { I }
    @Title { El Problema }
  @Begin
    @BeginSections
      @Section
        @Title { Planteamiento del Problema  y Justificación de la Investigación }
        @Tag { planteamiento }
      @Begin
        @AddToIndex
          @Title { Planteamiento del Problema  y Justificación de la Investigación }
          @Tag { planteamiento }

        @PP
        La época actual es llamada la ``era de la información'' (Giuliano, 1983) debido a la relevancia de ésta
        en la sociedad. Furth (1994) escribió: ``La información es actualmente tan vital, y tan intangible, como
        el aire que respiramos, el cual está lleno de ondas de radio''. Hoy en día es el bien más importante y
        valioso para toda compañía, país y grupo social, por lo que su refinamiento a partir de la abundante
        cantidad de datos que son creados cada segundo es un proceso primordial y que ofrece una ventaja
        significativa.
        @PP
        En el año 2010 se produjo y almacenó un estimado de dos exabytes de información (esto incluye todos los
        medios: libros, revistas, documentos, Internet, fotografías, televisión, radio, música, entre otros) de
        los cuales, el 93% era digital (Burgin, 2010). Dos años después, la cantidad de información digital
        generada, se elevó a 2.5 exabytes al día (IBM, 2012), evidenciando un crecimiento exponencial, con la
        Internet como principal catalizador de este fenómeno.
        @PP
        A la Internet se le suma el creciente uso de dispositivos móviles (teléfonos inteligentes, tabletas,
        lectores electrónicos, entre otros) que permiten la accesible y cómoda creación y consumo de información
        gracias a la web, lo cual provoca una cuantiosa producción de datos, además de contribuir con la
        heterogeneidad y descentralización de los mismos, ocasionando así que su tratamiento sea una tarea
        penosamente difícil de realizar.
        @PP
        En la actualidad, los distintos repositorios presentan al usuario la información digital en ellos
        almacenados mediante una estructura jerárquica de directorios en forma de árbol invertido. Esta
        representación, nacida en 1969 con el lanzamiento del sistema operativo Multics en respuesta a la
        necesidad de un sistema de almacenamiento secundario en un ambiente de multiprogramación (Multics,
        1968), rígida por causa de su inherente propiedad taxonómica, limita la manera en la que puede ser
        organizada la información, mediante una relación padre-hijo, y hace de la búsqueda de la misma un
        proceso arduo debido al uso de engorrosas rutas de directorios. Además, esta aproximación dista en gran
        medida del método natural usado por el hombre para almacenar y recuperar información de su memoria a
        largo plazo, el cual consiste en codificarla semánticamente para su almacenamiento (Baddeley, 1966),
        asociando los datos que percibe (Atkinson y Shiffrin, 1968). Por lo tanto, el ser humano no es una
        máquina que trabaje en base a datos aislados, éste busca interrelacionarlos, describiéndolos de manera
        inherentemente subjetiva, breve y dinámica; haciendo necesario un método semejante para clasificar y
        recuperar la información digital, siendo éste más flexible, intuitivo y natural.
        @PP
        Afortunadamente, la web ha dado origen a un nuevo sistema de clasificación. Originalmente diseñado e
        implantado por el servicio del.icio.us (Mathes, 2004), el sistema ofrece la posibilidad de describir
        recursos mediante un conjunto de palabras clave llamadas etiquetas (@I tags, por su término en inglés),
        las cuales son consideradas por los usuarios como relevantes para caracterizar dichos recursos de
        acuerdo a sus necesidades sin depender de un vocabulario controlado o de una estructura previamente
        definida, estableciendo así una relación entre el recurso y un concepto en su mente, con el objeto de
        organizar el contenido para uso futuro de una manera fácil y flexible (Specia y Motta, 2007). Este
        esquema de catalogación se ha extendido en uso por una gran variedad de servicios web debido a su
        popularidad entre los usuarios, quienes ven en éste una manera más natural, sencilla, rápida y personal
        de clasificar la información digital que les es de interés, hallándola posteriormente con mínimo
        esfuerzo, siendo ésta una mejor alternativa al problema de darle tratamiento a una gran cantidad de
        datos, contrastada con la estructura jerárquica que ofrecen los sistemas de archivos modernos.
        @PP
        Hoy en día, existe una serie de herramientas que extienden las capacidades de los sistemas de archivos
        al permitir el uso de etiquetas; sin embargo, estas herramientas presentan algunas limitaciones, tales
        como: el tratamiento exclusivo de una fracción de la información digital existente, su operación bajo un
        número reducido de plataformas, la prestación de un conjunto restringido de funcionalidades, entre
        otros.
        @PP
        Con este trabajo de investigación se buscó desarrollar una herramienta web integral que garantizara la
        interoperabilidad entre los distintos sistemas operativos y dispositivos al permitir un acceso
        convenientemente centralizado a la información digital sin importar la distribución física de ésta,
        brindando así transparencia de localización mediante el uso de un servidor central que contenga la
        herramienta y aplicaciones que enlacen los repositorios de los usuarios con dicho servidor. Además, se
        implantó una manera sencilla, versátil y personal de clasificar y recuperar la información digital
        contenida en los mencionados repositorios al permitir su descripción y recuperación mediante el uso de
        etiquetas definidas a conveniencia. Adaptando así la tecnología nacida en la web al ámbito de los
        actuales sistemas de archivo.
      @End @Section

      @Section
        @Title { Alcance del problema }
        @Tag { alcance }
      @Begin
        @AddToIndex @Title { Alcance del problema } @Tag { alcance }

        @PP
        La investigación estuvo delimitada al desarrollo de un sistema cliente-servidor donde el cliente,
        desarrollado para trabajar solo bajo los entornos Windows®, OS X® y Linux®, se comunica con una
        aplicación web, manteniendo sincronizadas las etiquetas asociadas a los archivos ubicados en los
        repositorios del usuario, permitiéndole así clasificarlos y recuperarlos mediante el uso de las
        mencionadas etiquetas.
      @End @Section

      @Section
        @Title { Objetivos }
        @Tag { objetivos }
      @Begin
        @AddToIndex @Title { Objetivos } @Tag { objetivos }

        @BeginSubSections
          @SubSection
            @Title { Objetivo General }
            @Tag { obj.gen }
          @Begin
            @AddToIndex @Title { Objetivo General } @Tag { obj.gen }

            //2.4f @BulletList
              @ListItem {
                Desarrollar una herramienta web para la clasificación y recuperación de información
                digital basada en etiquetas
              }
            @EndList
          @End @SubSection

          @SubSection
            @Title { Objetivos Específicos }
            @Tag { obj.esp }
          @Begin
            @AddToIndex @Title { Objetivos Específicos } @Tag { obj.esp }

            //2.4f @BulletList
            @ListItem {
              Realizar una revisión documental sobre herramientas de clasificación y recuperación de
              información digital
            }
            @ListItem {
              Implementar la aplicación servidor para el almacenamiento y gestión de etiquetas de recursos
              digitales
            }
            @ListItem {
              Desarrollar el módulo de la aplicación cliente encargada del rastreo personalizable de la
              información a etiquetar
            }
            @ListItem {
              Desarrollar el módulo de la aplicación cliente correspondiente a la interfaz web de usuario
            }
            @ListItem {
              Realizar las pruebas de caja gris de la herramienta
            }
            @EndList
          @End @SubSection
        @EndSubSections
      @End @Section
    @EndSections
  @End @Chapter

  @NP

  @Chapter
    @Num { II }
    @Title { Marco Teórico }
  @Begin
    @BeginSections
      @Section
        @Title { Antecedentes de la Investigación }
        @Tag { antecedentes }
      @Begin
        @AddToIndex @Title { Antecedentes de la Investigación } @Tag { antecedentes }

        @PP
        En la actualidad, los sistemas de clasificación basados en etiquetas son ampliamente usados por
        innumerables aplicaciones web, sin embargo, su uso como complemento a los sistemas de archivo modernos
        presenta una reducida gama de opciones, dentro de la cual se pueden mencionar:

        @BeginSubSections
          @SubSection
            @Title { Tags }
            @Tag { ant.tags }
          @Begin
            @AddToIndex @Title { Tags } @Tag { ant.tags }

            @PP
            Tags es una aplicación que permite etiquetar archivos y directorios en @I finder (explorador),
            correos electrónicos en @I Mail (gestor de emails), fotos en @I IPhoto (gestor de imágenes) y
            enlaces en @I Safari (navegador web); con el objetivo de mantener organizados dichos recursos y
            poder hallarlos de manera rápida y sencilla.
            @PP
            Tags también ofrece una vista previa de la información, atajos de teclado y una excelente
            integración con el sistema operativo. Desafortunadamente, esta aplicación solo está disponible
            para el sistema operativo @I { OS X }®, está sujeta a una licencia privativa y no es capaz de
            sincronizar recursos localizados en dispositivos diferentes.

            //2.4f @MyCenter @B { Gráfica 1. Tags }
            //0f @CD { 0.4 0.28 } @Scale @IncludeGraphic "./include/img/tags.eps"
            //0f @MyCenter @B { Fuente: Tags (2014) }
          @End @SubSection

          @SubSection
            @Title { TagTool }
            @Tag { ant.tagtool }
          @Begin
            @AddToIndex @Title { TagTool } @Tag { ant.tagtool }

            @PP
            TaggTool permite añadir etiquetas a archivos, directorios y «bookmarks». Adicionalmente, el
            usuario puede proporcionar una descripción del recurso, además de una calificación cuantitativa
            (@I rating). Esta herramienta ofrece la posibilidad de importar metadatos pre-existentes en los
            recursos y realizar búsquedas en base a estos.
            @PP
            TaggTool también posee una alta integración con el sistema operativo y brinda una vista previa
            de los recursos gestionados. Además, facilita un sistema de etiquetado automático basado en la
            naturaleza de los recursos, y muestra una nube de etiquetas para la visualización de las
            mismas.
            @PP
            Al igual que Tags, TaggTool está sujeto a una licencia privativa y no es capaz de sincronizar
            recursos localizados en dispositivos diferentes. Otra desventaja que presenta este sistema
            es que está disponible solo para el sistema operativo @I { Microsoft Windows }®.

            //2.4f @MyCenter @B { Gráfica 2. TaggTool }
            //0f @CD { 0.4 0.3 } @Scale @IncludeGraphic "./include/img/taggtool.eps"
            //0f @MyCenter @B { Fuente: TaggTool (2014) }
          @End @SubSection

          @SubSection
            @Title { Tables }
            @Tag { ant.tables }
          @Begin
            @AddToIndex @Title { Tables } @Tag { ant.tables }

            @PP
            Tabbles ofrece la posibilidad de clasificar, buscar, organizar y compartir (a través de una LAN
            o la Internet) archivos, carpetas y «bookmarks», mediante el uso de etiquetas. Adicionalmente,
            la herramienta ofrece un sistema de auto-etiquetado, además de una excelente integración con el
            sistema operativo.
            @PP
            A pesar de ser capaz de gestionar, compartir y sincronizar recursos localizados en dispositivos
            distintos, Tabbles está disponible únicamente para el sistema operativo Microsoft Windows® bajo
            una licencia privativa.

            //2.4f @MyCenter @B { Gráfica 3. Tabbles }
            //0f @CD { 0.6  0.5 } @Scale @IncludeGraphic "./include/img/tabbles.eps"
            //0f @MyCenter @B { Fuente: Tabbles (2014) }
          @End @SubSection
        @EndSubSections
      @End @Section

      @Section
        @Title { Bases Teóricas }
        @Tag { bases.teoricas }
      @Begin
        @AddToIndex @Title { Bases Teóricas } @Tag { bases.teoricas }

        @BeginSubSections
          @SubSection
            @Title { Sistema de Archivo }
            @Tag { sis.arch }
          @Begin
            @AddToIndex @Title { Sistema de Archivo } @Tag { sis.arch }

            @PP
            Un sistema de archivo es un módulo central de todo sistema operativo moderno que consiste de
            estructuras lógicas y rutinas que controlan la creación, modificación, eliminación y acceso a los
            datos que residen en una unidad de disco, partición o volumen lógico. Dicho sistema organiza los
            datos en una estructura jerárquica mediante el uso de directorios, los cuales fungen como
            contenedores de punteros a múltiples archivos (EMC, 2012). Algunos de los sistemas de archivo más
            ampliamente usados en la actualidad son: FAT, FAT32, NTFS, HFS Plus, ext2, ext3 y ext4.
          @End @SubSection

          @SubSection
            @Title { Transparencia de Localización }
            @Tag { trans.loca }
          @Begin
            @AddToIndex @Title { Transparencia de Localización } @Tag { trans.loca }

            @PP
            Se refiere a una consideración de diseño de los sistemas operativos distribuidos. Se habla de
            transparencia de localización cuando un usuario accede a un recurso en particular sin que sea
            necesario conocer la ubicación del mismo dentro de la red de trabajo a fin de acceder a él. El no
            conocer la localización de un recurso implica que todo acceso a éste es realizado por medio de un
            nombre que no depende de la ubicación dónde reside actualmente, ni la ubicación dónde fue
            creado (Borghoff y Schlichter, 2000).
          @End @SubSection

          @SubSection
            @Title { Aplicación Web }
            @Tag { web.app }
          @Begin
            @AddToIndex @Title { Aplicación Web } @Tag { web.app }

            @PP
            Es una aplicación desarrollada mediante el uso de tecnologías web (html, css, javascript, entre otros)
            cuyo entorno de ejecución (@I{ runtime enviroment }) está conformado por un motor web (@I{ web engine }).
            Como ejemplos de este tipo de aplicaciones se pueden mencionar: sistemas de reservación, sitios de
            compras en línea, juegos, aplicaciones multimedia, mapas, aplicaciones interactivas de diseños,
            sistemas de correo, entre otros (W3C, 2012).

            @PP
            Los cuatros componentes típicos de una aplicación web son: un navegador, un servidor web, programas de
            aplicación y un servidor de base de datos. Las responsabilidades del navegador incluyen: presentar una
            interfaz de usuario, comunicarse con un servidor web, ejecutar @I{ scripts } embebidos, gestionar la
            @I{ cache } y las @I{ cookies }. El servidor web se encarga, entre otras cosas, de comunicarse con los
            clientes, proveer contenido estático, invocar programas de aplicación para la generación de contenido
            dinámico y gestionar las conexiones (Grove, 2009).

            @PP
            @I{ CGI }, @I{ servlets }, lenguajes de plantilla (@I{ template languages }) y lenguajes de guión
            (@I{ script languages }) son algunos de los entornos de desarrollo para la construcción de los
            programas de aplicación mencionados anteriormente, y están típicamente acompañados por un sistema de
            gestión de base de datos relacional (@I{ RDBMS }, por sus siglas en inglés) accedido por los programas
            de aplicación a través de un @I{ ODBC } "/" @I{ ORM } (Grove, 2009).
          @End @SubSection

          @SubSection
            @Title { ORM }
            @Tag { orm }
          @Begin
            @AddToIndex @Title { ORM } @Tag { orm }

            @PP
            Es una herramienta que permite conectar un objeto, a veces llamado ``modelo de dominio'', con una base de
            datos relacional de manera automática mediante el uso de metadatos como descriptores del objeto y los
            datos en sí mismos. Algunas de las ventajas que ofrece el uso de un ORM sobre otras técnicas de acceso
            de datos se listan a continuación: en primer lugar, se automatiza la conversión bidireccional entre
            objetos y tablas; además, se provee el almacenamiento en @I{ cache } de los objetos de manera
            transparente en el lado de la aplicación, mejorando así el rendimiento del sistema; y por último,
            brinda una API de acceso a la base de datos, abstrayendo por completo el sistema de gestión de bases de
            datos relacional (Mehta, 2008). @I{ ODB }, @I{ JDBC }, @I{ Peewee }, @I{ SQLAlchemist } y @I{ Yii } son
            algunos de los ORM usados en la actualidad.
          @End @SubSection

          @SubSection
            @Title { AJAX }
            @Tag { ajax }
          @Begin
            @AddToIndex @Title { AJAX } @Tag { ajax }

            @PP
            Es una tecnología empleada para prevenir la carga de una página en su totalidad al permitir la
            transferencia de datos entre el cliente y el servidor web de manera asíncrona, logrando que las páginas
            se carguen más rápidamente al retrasar la descarga de grandes recursos (Zakas, 2010).
          @End @SubSection

          @SubSection
            @Title { JSON }
            @Tag { json }
          @Begin
            @AddToIndex @Title { JSON } @Tag { json }

            @PP
            Es un formato ligero y fácil de analizar sintácticamente para representar datos, basado en el uso de la
            sintaxis dispuesta para los literales de tipo arreglo y objeto en el lenguaje de programación
            JavaScript, usado generalmente para transmitir información entre distintos sistemas de software (Zakas,
            2010). La serialización de información estructurada, tarea que se solía realizar con XML, es
            actualmente llevada a cabo mediante el uso del formato JSON, tendencia que crece con el pasar del
            tiempo.
          @End @SubSection

          @SubSection
            @Title { WSGI }
            @Tag { wsgi }
          @Begin
            @AddToIndex @Title { WSGI } @Tag { wsgi }

            @PP
            Es una interfaz simple y universal entre servidores y aplicaciones web para el lenguaje de programación
            Python (Eby, 2010). En términos simples, esta especificación establece la CGI (@I{ Common Gateway Interface })
            para el lenguaje de programación Python.
          @End @SubSection
        @EndSubSections
      @End @Section

      @Section
        @Title { Descripción de las Herramientas Usadas }
        @Tag  { herramientas.usadas }
        @Begin
          @AddToIndex @Title { Descripción de las Herramientas Usadas } @Tag  { herramientas.usadas }

        //2.0f @BulletList
          @ListItem {
            Python: es un lenguaje de programación de código abierto y de propósito general. Cuenta con una
            sintaxis simple y legible. Soporta los paradigmas: orientado a objetos, funcional, y procedural. El
            dominio de aplicación del lenguaje va desde sistemas de administración, desarrollo de paginas web, y
            educación hasta el análisis computacional de inversión, el desarrollo de video juegos y el control
            aéreo (Lutz, 2010).
          }

          @ListItem {
            Flask: es un @I{ microframework } web para el lenguaje de programación Python. Su principal
            característica recae en poseer un conjunto de funcionalidades reducido y simple, brindando gran detalle
            a la extensibilidad de la herramienta, permitiéndole al usuario elegir los componentes a integrar,
            adaptándose así a las necesidades del proyecto a desarrollar y a las preferencias de los usuarios de
            manera flexible e indolora (Flask.org, 2014).
          }

          @ListItem {
            Pewee: es un ORM simple, escrito en python, que provee una interfaz ligera para realizar consultas SQL
            (Leifer, 2014).
          }

          @ListItem {
            SQLite: es una librería que implementa un motor de base de datos SQL transaccional y auto contenido.
            Sobresale entre sus características el poseer una arquitectura que no concibe la existencia de un
            proceso servidor, almacenando los datos gestionados en un archivo ordinario (SQLite.org, 2014).
          }

          @ListItem {
            Twitter bootstrap: es un @I{ framework } HTML, CSS y JavaScript para desarrollar proyectos web
            adaptables (@I{ responsive }) y orientados a dispositivos móviles (@I{ mobile first })
            (getbootstrap.com, 2014).
          }

          @ListItem {
            JQuery: es una librería escrita en JavaScript rápida, simple y con una gran repertorio de utilidades.
            Hace de la manipulación del DOM, el manejo de eventos, la creación de animaciones y el uso de Ajax,
            tareas mucho más sencillas de realizar a través de una API multiplataforma (JQuery.com, 2014).
          }
        @EndList
      @End @Section
    @EndSections
  @End @Chapter

  @NP
  @Chapter
    @Num { III }
    @Title { Marco Metodológico }
  @Begin
    @BeginSections
      @Section
        @Title { Descripción de la Metodología Empleada }
        @Tag { desc.met }
      @Begin
        @AddToIndex @Title { Descripción de la Metodología Empleada } @Tag { desc.met }

        @PP
        Para el desarrollo de la herramienta, fruto de esta investigación, se empleó la metodología @I{ Scrum }, la
        cual se define como un ``marco de trabajo en el cual las personas abordan problemas adaptativos complejos,
        entregando productos del más alto valor posible de manera productiva y creativa'' (Schwaber y Sutherland,
        2011). @I{ Scrum } está fundamentada en el empirismo, el cual afirma que el conocimiento viene de la
        experiencia y que la toma de decisiones debe basarse en lo que se sabe. También, vale mencionar que esta
        metodología emplea un modelo iterativa e incremental para optimizar la capacidad de predicción y el control
        de riesgos.

        @PP
        El corazón del @I{ Scrum } es el @I{ Sprint }, el cual es un lapso de tiempo, cuya duración no supera la de
        un mes, durante el cual un incremento de un producto terminado, usable y potencialmente entregable es
        creado. Un @I{ Sprint } abarca lo que se va a construir, la elaboración de un plan flexible para llevar a
        cabo dicho proceso, la construcción en sí misma y el producto resultante.

        @PP
        En cuanto a las pruebas del sistema, se optó por la aplicación de dos tipos: pruebas funcionales orientadas
        a tareas (@I{ Task-Oriented Functional Tests }) y pruebas de errores forzados (@I{ Forced-Error Tests }),
        ambas ejecutadas bajo el modelo de caja gris.

        @PP
        De acuerdo a Hung Nguyen, Bob Johnson y Michael Hackett, las pruebas funcionales orientadas a tareas
        consisten de casos de prueba positivos que son diseñados para verificar las características del programa al
        asegurarse de que cada una de ellas se comporte como se espera, tomando en cuenta las especificaciones,
        guías de usuario, requerimientos y documentos de diseño. Cada característica es probada para:

        //2.0f @BulletList indent { 4s }
          @ListItem {
            Validar que la tarea se ejecute adecuadamente dadas condiciones de dato adecuadas bajo condiciones
            operativas favorables.
          }
          @ListItem {
            Verificar la integridad del resultado final de la tarea.
          }
          @ListItem {
            Asegurar la integridad de la característica cuando se usa junto a otras.
          }
        @EndList

        @PP
        Por su parte, las pruebas de errores forzados, según Nguyen, Johnson y Hackett, son casos de prueba
        negativos diseñados para forzar a un programa a pasar a condiciones de error. Debe generarse una lista de
        todos los mensajes de error que el programa emite. Esta lista es usada como base en el desarrollo de
        casos de prueba. Algunas recomendaciones a la hora de llevar a cabo este tipo de pruebas se describen a
        continuación:

        //2.0f @BulletList indent { 4s }
          @ListItem {
            Verificar que todas las condiciones de error comunes sean detectadas y manejadas correcta y
            consistentemente.
          }
          @ListItem {
            Verificar que el programa se recupere correctamente para toda condición de error.
          }
          @ListItem {
            Verificar que los estados inestables del programa, causados por un error, también sean corregidos.
          }
        @EndList

        @PP
        Por último, el modelo (o pruebas, como también es conocido) de caja gris incorpora elementos de las
        pruebas de caja negra y blanca. En las pruebas de caja gris se considera el resultado desde el punto de
        vista del usuario, el conocimiento técnico específico del sistema y el ambiente operativo; además, estas
        pruebas evalúan el diseño de la aplicación bajo el contexto de la interoperabilidad entre los componentes
        del sistema.

        @PP
        El modelo de caja gris es ideal para poner a prueba de manera efectiva aplicaciones web debido a que
        éstas abarcan numerosos componentes, tanto de software como de hardware. Estos componentes deben ser
        probados en el contexto del diseño del sistema para evaluar su funcionalidad y compatibilidad.
      @End @Section

      @Section
        @Title { Desarrollo de la Herramienta Balo la Metodología Scrum }
        @Tag { desarr.met }
      @Begin
        @AddToIndex @Title { Desarrollo de la Herramienta Balo la Metodología Scrum } @Tag { desarr.met }

        @PP
        El desarrollo de la herramienta web, Omnitag, se llevó a cabo a lo largo de nueve @I{ Sprints }, cada uno
        de un mes de duración. La distribución de las tareas llevadas a cabo a lo largo del ciclo de desarrollo se
        ha plasmado en la siguiente tabla, la descripción de las mismas se plantea justo después de la mencionada
        tabla.

        @NP

        @AddToIndex @Title { Distribución de Actividades } @Tag { dist.act }
        @PageMark { dist.act } @AddToTIndex @Title { Tabla 1. Cronograma } @Tag { dist.act }

        //2.4f @MyCenter @B { Tabla 1. Distribución de Actividades }
        //0f @CD { 0.36 0.36 } @Scale @IncludeGraphic "./include/img/tabla1.eps"
        //0f @MyCenter @B { Fuente: Padrón (2014) }

        @BeginSubSections
          @SubSection
            @Title { Primer Sprint }
            @Tag { sp.1 }
          @Begin
            @AddToIndex @Title { Primer Sprint } @Tag { sp.1 }

            @PP
            Durante este @I{ sprint } se culminó la revisión de literatura relacionada con los sistemas de
            clasificación y recuperación de información digital basados en etiquetas, con la recopilación de los
            antecedentes de esta investigación. Además, se comenzó a diseñar e implementar la interfaz web de usuario
            a través del diseño de bocetos físicos y digitales; y la base de datos, mediante el esquema fundamental
            de la misma. Adicionalmente, se dio inicio al proceso de codificación e implementación de la aplicación
            servidor, diseñando la funcionalidad base para recibir y responder peticiones HTTP. Todo esto junto a las
            respectivas pruebas de caja gris de los componentes desarrollados, acción que se mantuvo durante todo el
            ciclo de desarrollo de la herramienta.
          @End @SubSection

          @SubSection
            @Title { Segundo Sprint }
            @Tag { sp.2 }
          @Begin
            @AddToIndex @Title { Segundo Sprint } @Tag { sp.2 }

            @PP
            Durante este @I{ sprint } se continuó con las actividades iniciadas en el anterior refinando el diseño
            de la base de datos, añadiendo nuevas características a la aplicación servidor y mejorando la interfaz
            web de usuario con el fin de hacerla más intuitiva y funcional.
          @End @SubSection

          @SubSection
            @Title { Tercer Sprint }
            @Tag { sp.3 }
          @Begin
            @AddToIndex @Title { Tercer Sprint } @Tag { sp.3 }

            @PP
            Al igual que en el anterior, durante este @I{ sprint } se dio continuidad a las labores anteriormente
            descritas, añadiendo un nuevo conjunto de características a la aplicación servidor, reflejando éstas
            mejoras en la interfaz web del usuario y dándole los toques finales a la base de datos, finalizando el
            proceso de diseño e implementación de la misma.
          @End @SubSection

          @SubSection
            @Title { Cuarto Sprint }
            @Tag { sp.4 }
          @Begin
            @AddToIndex @Title { Cuarto Sprint } @Tag { sp.4 }

            @PP
            En este @I{ Sprint } se comenzó el diseño de una API pública, implementada en la aplicación servidor,
            para permitir una comunicación sencilla con la misma, potenciando así la posibilidad de desarrollar una
            aplicación cliente que se comunique con la aplicación servidor de manera efectiva. También se hicieron
            un par de cambios menores a la interfaz web de usuario.
          @End @SubSection

          @SubSection
            @Title { Quinto Sprint }
            @Tag { sp.5 }
          @Begin
            @AddToIndex @Title { Quinto Sprint } @Tag { sp.5 }

            @PP
            Es en este @I{ Sprint } que se da inicio a la codificación e implementación de la aplicación cliente,
            conformada, al final de este ciclo, solo por el mecanismo de rastreo de recursos del sistema. Por otro
            lado, se sigue con la expansión de la API mencionada anteriormente y el refinamiento de la interfaz web
            de usuario, acciones que se repiten hasta el final del tercer lanzamiento.
          @End @SubSection

          @SubSection
            @Title { Sexto Sprint }
            @Tag { sp.6 }
          @Begin
            @AddToIndex @Title { Sexto Sprint } @Tag { sp.6 }

            @PP
            Se desarrolló el módulo que permite al usuario seleccionar a potestad cuáles directorios serán
            incluidos en el proceso de rastreo, así como el módulo que se encarga de mantener sincronizada con el
            servidor la información generada a partir del mencionado rastreo.
          @End @SubSection

          @SubSection
            @Title { Septimo Sprint }
            @Tag { sp.7 }
          @Begin
            @AddToIndex @Title { Septimo Sprint } @Tag { sp.7 }

            @PP
            A lo largo de este sprint, se implementó la gestión de usuarios en la aplicación servidor, se adaptó la
            interfaz web de usuario para reflejar dichos cambios y se implementó en ambas aplicaciones un mecanismo
            de comunicación sencillo, robusto y seguro, basado en @I{ tokens }.
          @End @SubSection

          @SubSection
            @Title { Octavo Sprint }
            @Tag { sp.8 }
          @Begin
            @AddToIndex @Title { Octavo Sprint } @Tag { sp.8 }

            @PP
            Durante este @I{ Sprint } se desarrolló e integró un mecanismo de etiquetado automático de la
            información rastreada.
          @End @SubSection

          @SubSection
            @Title { Noveno Sprint }
            @Tag { sp.9 }
          @Begin
            @AddToIndex @Title { Noveno Sprint } @Tag { sp.9 }

            @PP
            Este @I{ Sprint } cerró el ciclo de desarrollo de esta investigación, durante el cual se llevaron a
            cabo las pruebas más rigurosas del sistema, con la finalidad de detectar y posteriormente corregir
            errores funcionales que residían en la aplicación.
          @End @SubSection
        @EndSubSections
      @End @Section
    @EndSections
  @End @Chapter

  @NP

  @Chapter
    @Num { IV }
    @Title { El título de este capítulo }
  @Begin
    @BeginSections
      @Section
        @Title { El título de esta sección }
        @Tag { 92183981293 }
      @Begin
        @PP
        En primer lugar, se describirán las clases que definen los modelos usados por el módulo servidor.
        @B BaseModel pauta la interfaz mínima que debe poseer todo modelo, obligando la implementación de tres
        métodos fundamentales, @I exist, que determina si un registro existe o no; @I { get_by_id }, el cual
        realiza una búsqueda de registros a partir de un conjunto de identificadores; y finalmente, @I json,
        el cual transforma un registro al formato @I { json }.
        @PP
        La clase @B User aglomera la información relacionada con el nombre e información de acceso de un
        usuario del sistema. Las clases @B Device, @B Search y @B Tag, son usadas para representar los
        dispositivos, búsquedas y etiquetas de los usuarios, respectivamente; estas clases dependen
        directamente de la clase @B User.
        @PP
        Por su lado, la clase @B Resource sirve para representar los recursos almacenados en los distintos
        dispositivos de los usuarios. Las clases @B TagResources y @B TagSearch son empleadas para relacionar
        etiquetas con recursos (en el primer caso) y búsquedas (en el segundo caso).
        @PP
        Las anteriores, están plasmadas en el diagrama de clases de la gráfica 4, presentada más abajo; y a
        excepción de @B BaseModel, corresponden a una y sola una tabla en la base de datos, describiendo en
        totalidad los modelos implementados en el sistema.
        @PP
        En el caso del módulo cliente, se tiene la clase @B Manager, la cual sirve como pilar fundamental al
        encargarse de la generación,  lectura y respaldo de los archivos de configuración y estado del
        sistema, así como también de la comunicación con el módulo servidor. El respaldo y comunicación con el
        servidor se lleva a cabo gracias a las clases @B Cache y @B SyncAgent, respectivamente. Estas tareas
        corresponden a dos hilos de ejecución independientes, ambos instancias de la clase @B DaemonThread.
        La clase @B Crawler encapsula las rutinas relacionados con el rastreo de recursos en el dispositivo
        anfitrión, mientras que la clase @B AutoTagger es la encargada del etiquetado automático de los
        mencionados recursos.
        @PP
        Por último, @B SettingsForm es una clase empleada en la verificación de los datos enviados por el
        usuario en el formulario dispuesto para la actualización de los parámetros de configuración del
        sistema.

        //2.4f @MyCenter @B { Gráfica 4. Diagrama de Clases de los Modelos }
        //0f @CD 0.4 @Scale @IncludeGraphic "./include/img/classes-serv.eps"
        //0f @MyCenter @B { Fuente: Padrón (2014) }

        @NP

        //2.4f @MyCenter @B { Gráfica 5. Diagrama de Clases del Módulo Cliente }
        //0f @CD 0.4 @Scale @IncludeGraphic "./include/img/classes-clnt.eps"
        //0f @MyCenter @B { Fuente: Padrón (2014) }
      @End @Section
    @EndSections
  @End @Chapter

  @NP

  @ExtraSection
    @Title { REFERENCIAS BIBLIOGRÁFICAS }
    @AlterTitle { Referencias bibliográficas }
  @Begin
    //1.2f @BulletList
      @ListItem {
        Atkinson, R.C.; Shiffrin, R.M. (1968). Chapter: Human memory: A proposed system and its control
        processes. The psychology of learning and motivation. pp. 89-195.
      }
      @ListItem {
        Baddeley, A.D. (1966). The influence of acoustic and semantic similarity on long-term memory for word
        sequences. The Quarterly Journal of Experimental Psychology. pp. 302-309.
      }
      @ListItem {
        Borghoff, Uwe; Schlichter, Johann (2000). Computer-Supported Cooperative Work: Introduction to
        Distributed Applications. Springer Science y Business Media. p. 6.
      }
      @ListItem {
        Burgin, Mark (2010). Theory of Information: Fundamentality, Diversity and Unification. World Scientific.
        p. VI.
      }
      @ListItem {
        Eby, Phillip (2010) (Página consultada el 16 de julio de 2014) [On-line]. Dirección:
        "http://legacy.python.org/dev/peps/pep-3333".
      }
      @ListItem {
        EMC Education Services (2012). Information Storage and Management: Storing, Managing, and Protecting
        Digital Information in Classic, Virtualized, and Cloud Environments. John Wiley "&" sons. p. 6.
      }
      @ListItem {
        Flask.org (2014)(Página consultada el 19 de julio de 2014) [On-line]. Dirección: "http://flask.pocoo.org/".
      }
      @ListItem {
        Furth, J. (1994). The Information Age in Charts, Fortune International.
      }
      @ListItem {
        getbootstrap.com (2014) (Página consultada el 19 de julio de 2014) [On-line]. Dirección:
        "http://getbootstrap.com/".
      }
      @ListItem {
        Giuliano, V.E. (1983). The United States of America in the Information Age, en Information Policy and
        Scientific Research, Elsevier, Amsterdam, pp. 59-76.
      }
      @ListItem {
        Grove, Ralph (2009). Web Based Application Development. Jones "&" Bartlett Publishers. p. 42.
      }
      @ListItem {
        IBM (2012) (Página consultada el 25 de junio de 2013) [On-line]. Dirección:
        "www-01.ibm.com/software/data/bigdata/"
      }
      @ListItem {
        JQuery.com (2014) (Página consultada el 19 de julio de 2014) [On-line]. Dirección: "http://jquery.com/".
      }
      @ListItem {
        Leifer, Charles (2014) (Página consultada el 19 de julio de 2014) [On-line]. Dirección:
        "http://peewee.readthedocs.org/".
      }
      @ListItem {
        Mark Lutz (2010). Programming Python. O"'"Reilly Media, Inc. 
      }
      @ListItem {
        Mathes, Adam (2004) (Página consultada el 25 de junio de 2013) [On-line]. Dirección:
        "www.adammathes.com/academic/computer-mediated-communication/folksonomies.html"
      }
      @ListItem {
        Mehta, Vijay (2008). Pro LINQ Object Relational Mapping in C"#" 2008. Apress. pp. 4-5.
      }
      @ListItem {
        Multics (1968) (Página consultada el 25 de junio de 2013) [On-line]. Dirección:
        "www.multicians.org/fjcc4.html"
      }
      @ListItem {
        Nguyen, Hung; Johnson, Bob; Hackett, Michael (2003). Testing Applications on the Web: Test Planning for
        Mobile and Internet-Based Systems. Second Edition. Wiley Publishing, Inc.
      }
      @ListItem {
        Schwaber, Ken; Sutherland, Jeff (2011). The Definitive Guide to Scrum: The Rules of the Game.
      }
      @ListItem {
        Specia, Lucia; Motta, Enrico (2007). Integrating Folksonomies with the Semantic Web. Knowledge Media
        Institute - The Open University.
      }
      @ListItem {
        SQLite.org (2014) (Página consultada el 19 de julio de 2014) [On-line]. Dirección:
        "https://sqlite.org/about.html".
      }
      @ListItem {
        World Wide Web Consortium (2012) (Página consultada el 16 de julio de 2014) [On-line]. Dirección:
        "http://www.w3.org/2012/webapps/charter/"
      }
      @ListItem {
        Zakas, Nicholas (2010). High Performance JavaScript. O"'"Reilly Media, Inc.
      }
    @EndList
  @End @ExtraSection
@End @TEG
@End @Text
